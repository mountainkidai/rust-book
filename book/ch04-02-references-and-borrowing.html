<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>References and Borrowing - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="js-extensions/packages/feedback/dist/index.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="http://github.com/mountainkidai/rust-book/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="references-and-borrowing"><a class="header" href="#references-and-borrowing">References and Borrowing</a></h2>
<p>Ownership, boxes, and moves provide a foundation for safely programming with the heap. However, move-only APIs can be inconvenient to use. For example, say you want to read some strings twice:</p>
<pre><code class="language-aquascope interpreter shouldFail horizontal">fn main() {
    let m1 = String::from("Hello");
    let m2 = String::from("world");
    greet(m1, m2);`[]`
    let s = format!("{} {}", m1, m2);`[]` // Error: m1 and m2 are moved
}

fn greet(g1: String, g2: String) {
    println!("{} {}!", g1, g2);`[]`
}
</code></pre>
<p>In this example, calling <code>greet</code> moves the data from <code>m1</code> and <code>m2</code> into the parameters of <code>greet</code>. Both strings are dropped at the end of <code>greet</code>, and therefore cannot be used within <code>main</code>. If we try to read them like in the operation <code>format!(..)</code>, then that would be undefined behavior. The Rust compiler therefore rejects this program with the same error we saw last section:</p>
<pre><code class="language-text">error[E0382]: borrow of moved value: `m1`
 --&gt; test.rs:5:30
 (...rest of the error...)
</code></pre>
<p>This move behavior is extremely inconvenient. Programs often need to use a string more than once. An alternative <code>greet</code> could return ownership of the strings, like this:</p>
<pre><code class="language-aquascope interpreter horizontal">fn main() {
    let m1 = String::from("Hello");
    let m2 = String::from("world");`[]`
    let (m1_again, m2_again) = greet(m1, m2);
    let s = format!("{} {}", m1_again, m2_again);`[]`
}

fn greet(g1: String, g2: String) -&gt; (String, String) {
    println!("{} {}!", g1, g2);
    (g1, g2)
}
</code></pre>
<p>However, this style of program is quite verbose. Rust provides a concise style of reading and writing without moves through references.</p>
<h3 id="references-are-non-owning-pointers"><a class="header" href="#references-are-non-owning-pointers">References Are Non-Owning Pointers</a></h3>
<p>A <strong>reference</strong> is a kind of pointer. Here's an example of a reference that rewrites our <code>greet</code> program in a more convenient manner:</p>
<pre><code class="language-aquascope interpreter horizontal">fn main() {
    let m1 = String::from("Hello");
    let m2 = String::from("world");`[]`
    greet(&amp;m1, &amp;m2);`[]` // note the ampersands
    let s = format!("{} {}", m1, m2);
}

fn greet(g1: &amp;String, g2: &amp;String) { // note the ampersands
    `[]`println!("{} {}!", g1, g2);
}
</code></pre>
<p>The expression <code>&amp;m1</code> uses the ampersand operator to create a reference to (or "borrow") <code>m1</code>. The type of the <code>greet</code> parameter <code>g1</code> is changed to <code>&amp;String</code>, meaning "a reference to a <code>String</code>".</p>
<!-- At runtime, the references look like this:

<img src="img/experiment/ch04-02-stack1.jpg" class="center" width="350" /> -->
<p>Observe at L2 that there are two steps from <code>g1</code> to the string "Hello". <code>g1</code> is a reference that points to <code>m1</code> on the stack, and <code>m1</code> is a String containing a box that points to "Hello" on the heap.</p>
<p>While <code>m1</code> owns the heap data "Hello", <code>g1</code> does <em>not</em> own either <code>m1</code> or "Hello". Therefore after <code>greet</code> ends and the program reaches L3, no heap data has been deallocated. Only the stack frame for <code>greet</code> disappears. This fact is consistent with our <em>Box Deallocation Principle</em>. Because <code>g1</code> did not own "Hello", Rust did not deallocate "Hello" on behalf of <code>g1</code>.</p>
<p>References are <strong>non-owning pointers</strong>, because they do not own the data they point to.</p>
<h3 id="dereferencing-a-pointer-accesses-its-data"><a class="header" href="#dereferencing-a-pointer-accesses-its-data">Dereferencing a Pointer Accesses Its Data</a></h3>
<p>The previous examples using boxes and strings have not shown how Rust "follows" a pointer to its data. For example, the <code>println!</code> macro has mysteriously worked for both owned strings of type <code>String</code>, and for string references of type <code>&amp;String</code>. The underlying mechanism is the <strong>dereference</strong> operator, written with an asterisk (<code>*</code>). For example, here's a program that uses dereferences in a few different ways:</p>
<pre><code class="language-aquascope interpreter"># fn main() {
let mut x: Box&lt;i32&gt; = Box::new(1);
let a: i32 = *x;         // *x reads the heap value, so a = 1
*x += 1;                 // *x on the left-side modifies the heap value,
                         //     so x points to the value 2

let r1: &amp;Box&lt;i32&gt; = &amp;x;  // r1 points to x on the stack
let b: i32 = **r1;       // two dereferences get us to the heap value

let r2: &amp;i32 = &amp;*x;      // r2 points to the heap value directly
let c: i32 = *r2;`[]`    // so only one dereference is needed to read it
# }
</code></pre>
<p>Observe the difference between <code>r1</code> pointing to <code>x</code> on the stack, and <code>r2</code> pointing to the heap value <code>2</code>.</p>
<p>You probably won't see the dereference operator very often when you read Rust code. Rust implicitly inserts dereferences and references in certain cases, such as calling a method with the dot operator. For example, this program shows two equivalent ways of calling the <a href="https://doc.rust-lang.org/std/primitive.i32.html#method.abs"><code>i32::abs</code></a> (absolute value) and <a href="https://doc.rust-lang.org/std/primitive.str.html#method.len"><code>str::len</code></a> (string length) functions:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main()  {
</span>let x: Box&lt;i32&gt; = Box::new(-1);
let x_abs1 = i32::abs(*x); // explicit dereference
let x_abs2 = x.abs();      // implicit dereference
assert_eq!(x_abs1, x_abs2);

let r: &amp;Box&lt;i32&gt; = &amp;x;
let r_abs1 = i32::abs(**r); // explicit dereference (twice)
let r_abs2 = r.abs();       // implicit dereference (twice)
assert_eq!(r_abs1, r_abs2);

let s = String::from("Hello");
let s_len1 = str::len(&amp;s); // explicit reference
let s_len2 = s.len();      // implicit reference
assert_eq!(s_len1, s_len2);
<span class="boring">}</span></code></pre>
<p>This example shows implicit conversions in three ways:</p>
<ol>
<li>
<p>The <code>i32::abs</code> function expects an input of type <code>i32</code>. To call <code>abs</code> with a <code>Box&lt;i32&gt;</code>, you can explicitly dereference the box like <code>i32::abs(*x)</code>. You can also implicitly dereference the box using method-call syntax like <code>x.abs()</code>. The dot syntax is syntactic sugar for the function-call syntax.</p>
</li>
<li>
<p>This implicit conversion works for multiple layers of pointers. For example, calling <code>abs</code> on a reference to a box <code>r: &amp;Box&lt;i32&gt;</code> will insert two dereferences.</p>
</li>
<li>
<p>This conversion also works the opposite direction. The function <code>str::len</code> expects a reference <code>&amp;str</code>. If you call <code>len</code> on an owned <code>String</code>, then Rust will insert a single borrowing operator. (In fact, there is a further conversion from <code>String</code> to <code>str</code>!)</p>
</li>
</ol>
<p>We will say more about method calls and implicit conversions in later chapters. For now, the important takeaway is that these conversions are happening with method calls and some macros like <code>println</code>. We want to unravel all the "magic" of Rust so you can have a clear mental model of how Rust works.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch04-02-references-sec1-basics&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;`***y` is the correct expression. `y` has the type `Box&lt;&amp;Box&lt;i32&gt;&gt;`. It is a heap pointer to a stack reference \nto a heap pointer. Therefore `y` must be dereferenced three times, once for each layer of indirection.\n&quot;,&quot;id&quot;:&quot;0b8dbb4f-7c56-4b6e-8358-95c7b46f90c3&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;3&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Consider the following program, showing the state of memory after the last line:\n```aquascope,interpreter\n#fn main() {\nlet x = Box::new(0);\nlet y = Box::new(&amp;x);`[]`\n#}\n```\n\nIf you wanted to copy out the number `0` through `y`, how many dereferences would you need to use? \nWrite your answer as a digit. For example, if the correct expression is `*y`, then the answer is 1. \n&quot;}},{&quot;context&quot;:&quot;References are non-owning pointers. Therefore passing `&amp;v` to `get_first` does not move ownership of `v` into `get_first`,\nand subsequently `v` is not deallocated after `get_first` ends.\n&quot;,&quot;id&quot;:&quot;7cf19153-3647-4afc-953a-f9392ddb96fb&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`vr` is a reference which does not own the vector it points to&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`vr` is not mutated within `get_first`&quot;,&quot;`get_first` returns a value of type `i32`, not the vector itself&quot;,&quot;`v` is used after calling `get_first` in the `println`&quot;],&quot;prompt&quot;:&quot;Consider the following program, showing the state of memory after the last line:\n \n```aquascope,interpreter\nfn get_first(vr: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n  vr[0]\n}\n\nfn main() {\n  let mut v = vec![0, 1, 2];\n  let n = get_first(&amp;v);\n  println!(\&quot;{} {}\&quot;, n, v[1]);`[]` \n}\n```\n\nWhich of the following best explains why `v` is not deallocated after calling `get_first`?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h3 id="rust-avoids-simultaneous-aliasing-and-mutation"><a class="header" href="#rust-avoids-simultaneous-aliasing-and-mutation">Rust Avoids Simultaneous Aliasing and Mutation</a></h3>
<p>Pointers are a powerful and dangerous feature because they enable <strong>aliasing</strong>. Aliasing is accessing the same data through different variables. On its own, aliasing is harmless. But combined with <strong>mutation</strong>, we have a recipe for disaster. One variable can "pull the rug out" from another variable in many ways, for example:</p>
<ul>
<li>By deallocating the aliased data, leaving the other variable to point to deallocated memory.</li>
<li>By mutating the aliased data, invalidating runtime properties expected by the other variable.</li>
<li>By <em>concurrently</em> mutating the aliased data, causing a data race with nondeterministic behavior for the other variable.</li>
</ul>
<p>As a running example, we are going to look at programs using the vector data structure, <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>. Unlike arrays which have a fixed length, vectors have a variable length by storing their elements in the heap. For example, <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push"><code>Vec::push</code></a> adds an element to the end of a vector, like this:</p>
<pre><code class="language-aquascope interpreter horizontal">#fn main() {
let mut v: Vec&lt;i32&gt; = vec![1, 2, 3];`[]`
v.push(4);`[]`
#}
</code></pre>
<p>The macro <code>vec!</code> creates a vector with the elements between the brackets. The vector <code>v</code> has type <code>Vec&lt;i32&gt;</code>. The syntax <code>&lt;i32&gt;</code> means the elements of the vector have type <code>i32</code>.</p>
<p>One important implementation detail is that <code>v</code> allocates a heap array of a certain <em>capacity</em>. We can peek into <code>Vec</code>'s internals and see this detail for ourselves:</p>
<pre><code class="language-aquascope interpreter horizontal concreteTypes">#fn main() {
let mut v: Vec&lt;i32&gt; = vec![1, 2, 3];`[]`
#}
</code></pre>
<blockquote>
<p><em>Note:</em> click the binocular icon in the top right of the diagram to toggle this detailed view in any runtime diagram.</p>
</blockquote>
<p>Notice that the vector has a length (<code>len</code>) of 3 and a capacity (<code>cap</code>) of 3. The vector is at capacity. So when we do a <code>push</code>, the vector has to create a new allocation with larger capacity, copy all the elements over, and deallocate the original heap array. In the diagram above, the array <code>1 2 3 4</code> is in a (potentially) different memory location than the original array <code>1 2 3</code>.</p>
<p>To tie this back to memory safety, let's bring references into the mix. Say we created a reference to a vector's heap data. Then that reference can be invalidated by a push, as simulated below:</p>
<pre><code class="language-aquascope interpreter shouldFail horizontal">#fn main() {
let mut v: Vec&lt;i32&gt; = vec![1, 2, 3];
let num: &amp;i32 = &amp;v[2];`[]`
v.push(4);`[]`
println!("Third element is {}", *num);`[]`
#}
</code></pre>
<p>Initially, <code>v</code> points to an array with 3 elements on the heap. Then <code>num</code> is created as a reference to the third element, as seen at L1. However, the operation <code>v.push(4)</code> resizes <code>v</code>. The resize will deallocate the previous array and allocate a new, bigger array. In the process, <code>num</code> is left pointing to invalid memory. Therefore at L3, dereferencing <code>*num</code> reads invalid memory, causing undefined behavior.</p>
<p>In more abstract terms, the issue is that the vector <code>v</code> is both aliased (by the reference <code>num</code>) and mutated (by the operation <code>v.push(4)</code>). So to avoid these kinds of issues, Rust follows a basic principle:</p>
<blockquote>
<p><strong>Pointer Safety Principle</strong>: data should never be aliased and mutated at the same time.</p>
</blockquote>
<p>Data can be aliased. Data can be mutated. But data cannot be <em>both</em> aliased <em>and</em> mutated. For example, Rust enforces this principle for boxes (owned pointers) by disallowing aliasing. Assigning a box from one variable to another will move ownership, invalidating the previous variable. Owned data can only be accessed through the owner — no aliases.</p>
<p>However, because references are non-owning pointers, they need different rules than boxes to ensure the <em>Pointer Safety Principle</em>. By design, references are meant to temporarily create aliases. In the rest of this section, we will explain the basics of how Rust ensures the safety of references through the <strong>borrow checker.</strong></p>
<h3 id="references-change-permissions-on-places"><a class="header" href="#references-change-permissions-on-places">References Change Permissions on Places</a></h3>
<p>The core idea behind the borrow checker is that variables have three kinds of <strong>permissions</strong> on their data:</p>
<ul>
<li><strong>Read</strong> (@Perm{read}): data can be copied to another location.</li>
<li><strong>Write</strong> (@Perm{write}): data can be mutated.</li>
<li><strong>Own</strong> (@Perm{own}): data can be moved or dropped.</li>
</ul>
<p>These permissions don't exist at runtime, only within the compiler. They describe how the compiler "thinks" about your program before the program is executed.</p>
<p>By default, a variable has read/own permissions (@Perm{read}@Perm{own}) on its data. If a variable is annotated with <code>let mut</code>, then it also has the write permission (@Perm{write}). The key idea is
that <strong>references can temporarily remove these permissions.</strong></p>
<p>To illustrate this idea, let's look at the permissions on a variation of the program above that is actually safe. The <code>push</code> has been moved after the <code>println!</code>. The permissions in this program are visualized with a new kind of diagram. The diagram shows the changes in permissions on each line.</p>
<pre><code class="language-aquascope permissions stepper">#fn main() {
let mut v: Vec&lt;i32&gt; = vec![1, 2, 3];
let num: &amp;i32 = &amp;v[2];
println!("Third element is {}", *num);
v.push(4);
#}
</code></pre>
<p>Let's walk through each line:</p>
<ol>
<li>After <code>let mut v = (...)</code>, the variable <code>v</code> has been initialized (indicated by <i class="fa fa-level-up"></i>). It gains @Perm[gained]{read}@Perm[gained]{write}@Perm[gained]{own} permissions (the plus sign indicates gain).</li>
<li>After <code>let num = &amp;v[2]</code>, the data in <code>v</code> has been <strong>borrowed</strong> by <code>num</code> (indicated by <i class="fa fa-arrow-right"></i>). Three things happen:
<ul>
<li>The borrow removes @Perm[lost]{write}@Perm[lost]{own} permissions from <code>v</code> (the slash indicates loss). <code>v</code> cannot be written or owned, but it can still be read.</li>
<li>The variable <code>num</code> has gained @Perm{read}@Perm{own} permissions. <code>num</code> is not writable (the missing @Perm{write} permission is shown as a dash <span class="perm write">‒</span>) because it was not marked <code>let mut</code>.</li>
<li>The <strong>place</strong> <code>*num</code> has gained the @Perm{read} permission.</li>
</ul>
</li>
<li>After <code>println!(...)</code>, then <code>num</code> is no longer in use, so <code>v</code> is no longer borrowed. Therefore:
<ul>
<li><code>v</code> regains its @Perm{write}@Perm{own} permissions (indicated by <i class="fa fa-rotate-left"></i>).</li>
<li><code>num</code> and <code>*num</code> have lost all of their permissions (indicated by <i class="fa fa-level-down"></i>).</li>
</ul>
</li>
<li>After <code>v.push(4)</code>, then <code>v</code> is no longer in use, and it loses all of its permissions.</li>
</ol>
<p>Next, let's explore a few nuances of the diagram. First, why do you see both <code>num</code> and <code>*num</code>? Because accessing data through a reference is not the same as manipulating the reference itself. For example, say we declared a reference to a number with <code>let mut</code>:</p>
<pre><code class="language-aquascope permissions stepper">#fn main() {
let x = 0;
let mut x_ref = &amp;x;
# println!("{x_ref} {x}");
#}
</code></pre>
<p>Notice that <code>x_ref</code> has the @Perm{write} permission, while <code>*x_ref</code> does not. That means we can assign a different reference to the <code>x_ref</code> variable (e.g. <code>x_ref = &amp;y</code>), but we cannot mutate the data it points to (e.g. <code>*x_ref += 1</code>).</p>
<p>More generally, permissions are defined on <strong>places</strong> and not just variables. A place is anything you can put on the left-hand side of an assignment. Places include:</p>
<ul>
<li>Variables, like <code>a</code>.</li>
<li>Dereferences of places, like <code>*a</code>.</li>
<li>Array accesses of places, like <code>a[0]</code>.</li>
<li>Fields of places, like <code>a.0</code> for tuples or <code>a.field</code> for structs (discussed next chapter).</li>
<li>Any combination of the above, like <code>*((*a)[0].1)</code>.</li>
</ul>
<p>Second, why do places lose permissions when they become unused? Because some permissions are mutually exclusive. If you write <code>num = &amp;v[2]</code>, then <code>v</code> cannot be mutated or dropped while <code>num</code> is in use. But that doesn't mean it's invalid to use <code>num</code> again. For example, if we add another <code>println!</code> to the above program, then <code>num</code> simply loses its permissions one line later:</p>
<pre><code class="language-aquascope permissions stepper">#fn main() {
let mut v: Vec&lt;i32&gt; = vec![1, 2, 3];
let num: &amp;i32 = &amp;v[2];
println!("Third element is {}", *num);
println!("Again, the third element is {}", *num);
v.push(4);
#}
</code></pre>
<p>It's only a problem if you attempt to use <code>num</code> again <em>after</em> mutating <code>v</code>. Let's look at this in more detail.</p>
<h3 id="the-borrow-checker-finds-permission-violations"><a class="header" href="#the-borrow-checker-finds-permission-violations">The Borrow Checker Finds Permission Violations</a></h3>
<p>Recall the <em>Pointer Safety Principle</em>: data should not be aliased and mutated. The goal of these permissions is to ensure that data cannot be mutated if it is aliased. Creating a reference to data ("borrowing" it) causes that data to be temporarily read-only until the reference is no longer in use.</p>
<p>Rust uses these permissions in its <strong>borrow checker</strong>. The borrow checker looks for potentially unsafe operations involving references. Let's return to the unsafe program we saw earlier, where <code>push</code> invalidates a reference. This time we'll add another aspect to the permissions diagram:</p>
<pre><code class="language-aquascope permissions boundaries stepper shouldFail">#fn main() {
let mut v: Vec&lt;i32&gt; = vec![1, 2, 3];
let num: &amp;i32 = &amp;v[2];`{}`
v.push(4);`{}`
println!("Third element is {}", *num);
#}
</code></pre>
<p>Any time a place is used, Rust expects that place to have certain permissions depending on the operation. For example, the borrow <code>&amp;v[2]</code> requires that <code>v</code> is readable. Therefore the @Perm{read} permission is shown between the operation <code>&amp;</code> and the place <code>v</code>. The letter is filled-in because <code>v</code> has the read permission at that line.</p>
<p>By contrast, the mutating operation <code>v.push(4)</code> requires that <code>v</code> is readable and writable. Both @Perm{read} and @Perm{write} are shown. However, <code>v</code> does not have write permissions (it is borrowed by <code>num</code>). So the letter @Perm[missing]{write} is hollow, indicating that the write permission is <em>expected</em> but <code>v</code> does not have it.</p>
<p>If you try to compile this program, then the Rust compiler will return the following error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; test.rs:4:1
  |
3 | let num: &amp;i32 = &amp;v[2];
  |                  - immutable borrow occurs here
4 | v.push(4);
  | ^^^^^^^^^ mutable borrow occurs here
5 | println!("Third element is {}", *num);
  |                                 ---- immutable borrow later used here
</code></pre>
<p>The error message explains that <code>v</code> cannot be mutated while the reference <code>num</code> is in use. That's the surface-level reason — the underlying issue is that <code>num</code> could be invalidated by <code>push</code>. Rust catches that potential violation of memory safety.</p>
<h3 id="mutable-references-provide-unique-and-non-owning-access-to-data"><a class="header" href="#mutable-references-provide-unique-and-non-owning-access-to-data">Mutable References Provide Unique and Non-Owning Access to Data</a></h3>
<p>The references we have seen so far are read-only <strong>immutable references</strong> (also called <strong>shared references</strong>). Immutable references permit aliasing but disallow mutation. However, it is also useful to temporarily provide mutable access to data without moving it.</p>
<p>The mechanism for this is <strong>mutable references</strong> (also called <strong>unique references</strong>). Here's a simple example of a mutable reference with the accompanying permissions changes:</p>
<pre><code class="language-aquascope permissions stepper boundaries">#fn main() {
let mut v: Vec&lt;i32&gt; = vec![1, 2, 3];
let num: &amp;mut i32 = &amp;mut v[2];
*num += 1;
println!("Third element is {}", *num);
println!("Vector is now {:?}", v);
#}
</code></pre>
<blockquote><div style="margin-block-start: 1em; margin-block-end: 1em"><i>Note:</i> when the expected permissions are not strictly relevant to an example, we will abbreviate them as dots like <div class="permission-stack stack-size-2"><div class="perm read"><div class="small">•</div><div class="big">R</div></div><div class="perm write"><div class="small">•</div><div class="big">W</div></div></div>. You can hover your mouse over the circles (or tap on a touchscreen) to see the corresponding permission letters.</div></blockquote>
<p>A mutable reference is created with the <code>&amp;mut</code> operator. The type of <code>num</code> is written as <code>&amp;mut i32</code>. Compared to immutable references, you can see two important differences in the permissions:</p>
<ol>
<li>When <code>num</code> was an immutable reference, <code>v</code> still had the @Perm{read} permission. Now that <code>num</code> is a mutable reference, <code>v</code> has lost <em>all</em> permissions while <code>num</code> is in use.</li>
<li>When <code>num</code> was an immutable reference, the place <code>*num</code> only had the @Perm{read} permission. Now that <code>num</code> is a mutable reference, <code>*num</code> has also gained the @Perm{write} permission.</li>
</ol>
<p>The first observation is what makes mutable references <em>safe</em>. Mutable references allow mutation but prevent aliasing. The borrowed place <code>v</code> becomes temporarily unusable, so effectively not an alias.</p>
<p>The second observation is what makes mutable references <em>useful</em>. <code>v[2]</code> can be mutated through <code>*num</code>. For example, <code>*num += 1</code> mutates <code>v[2]</code>. Note that <code>*num</code> has the @Perm{write} permission, but <code>num</code> does not. <code>num</code> refers to the mutable reference itself, e.g. <code>num</code> cannot be reassigned to a <em>different</em> mutable reference.</p>
<p>Mutable references can also be temporarily "downgraded" to read-only references. For example:</p>
<pre><code class="language-aquascope permissions stepper boundaries">#fn main() {
let mut v: Vec&lt;i32&gt; = vec![1, 2, 3];
let num: &amp;mut i32 = &amp;mut v[2];`(focus,paths:*num)`
let num2: &amp;i32 = &amp;*num;`(focus,paths:*num)`
println!("{} {}", *num, *num2);
#}
</code></pre>
<blockquote>
<p><em>Note:</em> when permission changes are not relevant to an example, we will hide them. You can view hidden steps by clicking "»", and you can view hidden permissions within a step by clicking "● ● ●".</p>
</blockquote>
<p>In this program, the borrow <code>&amp;*num</code> removes the @Perm{write} permission from <code>*num</code> but <em>not</em> the @Perm{read} permission, so <code>println!(..)</code> can read both <code>*num</code> and <code>*num2</code>.</p>
<h3 id="permissions-are-returned-at-the-end-of-a-references-lifetime"><a class="header" href="#permissions-are-returned-at-the-end-of-a-references-lifetime">Permissions Are Returned At The End of a Reference's Lifetime</a></h3>
<p>We said above that a reference changes permissions while it is "in use". The phrase "in use" is describing a reference's <strong>lifetime</strong>, or the range of code spanning from its birth (where the reference is created) to its death (the last time(s) the reference is used).</p>
<p>For example, in this program, the lifetime of <code>y</code> starts with <code>let y = &amp;x</code>, and ends with <code>let z = *y</code>:</p>
<pre><code class="language-aquascope permissions stepper boundaries">#fn main() {
let mut x = 1;
let y = &amp;x;`(focus,paths:x)`
let z = *y;`(focus,paths:x)`
x += z;
#}
</code></pre>
<p>The @Perm{write} permission on <code>x</code> is returned to <code>x</code> after the lifetime of <code>y</code> has ended, like we have seen before.</p>
<p>In the previous examples, a lifetime has been a contiguous region of code. However, once we introduce control flow, this is not necessarily the case. For example, here is a function that capitalizes the first character in a vector of ASCII characters:</p>
<pre><code class="language-aquascope permissions stepper boundaries">fn ascii_capitalize(v: &amp;mut Vec&lt;char&gt;) {
    let c = &amp;v[0];`(focus,paths:*v)`
    if c.is_ascii_lowercase() {
        let up = c.to_ascii_uppercase();`(focus,paths:*v)`
        v[0] = up;
    } else {`(focus,paths:*v)`
        println!("Already capitalized: {:?}", v);
    }
}
</code></pre>
<p>The variable <code>c</code> has a different lifetime in each branch of the if-statement. In the then-block, <code>c</code> is used in the expression <code>c.to_ascii_uppercase()</code>. Therefore <code>*v</code> does not regain the @Perm{write} permission until after that line.</p>
<p>However, in the else-block, <code>c</code> is not used. <code>*v</code> immediately regains the @Perm{write} permission on entry to the else-block.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch04-02-references-sec2-perms&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The mutable borrow `t = &amp;mut s` removes all permissions on `s` while `t` is live.\n&quot;,&quot;id&quot;:&quot;2e273ac2-6f06-4c19-a831-1d44eed89323&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;No permissions&quot;]},&quot;prompt&quot;:{&quot;answerIndex&quot;:3,&quot;distractors&quot;:[&quot;R&quot;,&quot;W&quot;,&quot;O&quot;],&quot;prompt&quot;:&quot;Consider the permissions in the following program:\n\n```aquascope,permissions,stepper\n#fn main() {\nlet mut s = String::from(\&quot;Hello\&quot;);\nlet t = &amp;mut s;\n/* here */\nt.push_str(\&quot; world\&quot;);\nprintln!(\&quot;{}\&quot;, s);\n#}\n```\n\nAt the point marked `/* here */`, what are the permissions on the path `s`? Select each permission below, or select \&quot;no permissions\&quot; \nif the path has no permissions.\n&quot;}},{&quot;context&quot;:&quot;When `get_first` is called, Rust recognizes that the returned string `first` could point to data within `strs`, so `strs` loses \nwrite permissions. Once the `first` variable is no longer used (after the if-condition), then `strs` regains write permissions.\n&quot;,&quot;id&quot;:&quot;b431f43e-9a6f-4715-ae88-8896fca6ff3b&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`get_first` returns an immutable reference to data within `strs`, so `strs` is not writable while `first` is live&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`strs` is not writable while the immutable reference `&amp;strs` passed to `get_first` is live&quot;,&quot;`strs` does not need write permissions until the `strs.push(..)` operation, so it only regains write permissions at that statement&quot;,&quot;Because `first` refers to `strs`, then `strs` can only be mutated within a nested scope like the if-statement&quot;],&quot;prompt&quot;:&quot;Consider the permissions in the following program:\n\n```aquascope,permissions,stepper,boundaries\nfn get_first(v: &amp;Vec&lt;String&gt;) -&gt; &amp;String {\n    &amp;v[0]\n}\n\nfn main() {\n    let mut strs = vec![\n        String::from(\&quot;A\&quot;), String::from(\&quot;B\&quot;)\n    ];\n    let first = get_first(&amp;strs);\n    if first.len() &gt; 0 {\n        strs.push(String::from(\&quot;C\&quot;));\n    }\n}\n```\n\nWhich of the following best explains why `strs` loses and regains write permissions?\n&quot;}},{&quot;context&quot;:&quot;The undefined behavior arises because `v1` is read after being freed. Note that the other three options are correct statements\nabout the program, but they do not explain why the undefined behavior actually occurs. For example, if the `println` were deleted,\nthen the other three options are still true, but the program no longer has undefined behavior.\n&quot;,&quot;id&quot;:&quot;652e596c-7cc9-42e6-a7f8-701879cd9a2b&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`v1[0]` reads `v1`, which points to deallocated memory&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`v2` owns the vector data on the heap, while `v1` does not&quot;,&quot;`v1` has been moved into `v2` on line 2&quot;,&quot;`v1` has its pointer invalidated by the `push` on line 3&quot;],&quot;prompt&quot;:&quot;Consider this unsafe program:\n```aquascope,interpreter,shouldFail\n#fn main() {\nlet v1 = vec![1, 2, 3];\nlet mut v2 = v1;\nv2.push(4);\nprintln!(\&quot;{}\&quot;, v1[0]);`[]`    \n#}\n```\n\nWhich of the following best describes the point at which undefined behavior occurs in this program?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h3 id="data-must-outlive-all-of-its-references"><a class="header" href="#data-must-outlive-all-of-its-references">Data Must Outlive All Of Its References</a></h3>
<p>As a part of the <em>Pointer Safety Principle</em>, the borrow checker enforces that <strong>data must outlive any references to it.</strong> Rust enforces this property in two ways. The first way deals with references that are created and dropped within the scope of a single function. For example, say we tried to drop a string while holding a reference to it:</p>
<pre><code class="language-aquascope permissions stepper boundaries shouldFail">#fn main() {
let s = String::from("Hello world");
let s_ref = &amp;s;`(focus,rxpaths:s$)`
drop(s);`{}`
println!("{}", s_ref);
#}
</code></pre>
<p>To catch these kinds of errors, Rust uses the permissions we've already discussed. The borrow <code>&amp;s</code> removes the @Perm{own} permission from <code>s</code>. However, <code>drop</code> expects the @Perm{own} permission, leading to a permission mismatch.</p>
<p>The key idea is that in this example, Rust knows how long <code>s_ref</code> lives. But Rust needs a different enforcement mechanism when it doesn't know how long a reference lives. Specifically, when references are either input to a function, or output from a function. For example, here is a safe function that returns a reference to the first element in a vector:</p>
<pre><code class="language-aquascope permissions boundaries showFlows">fn first(strings: &amp;Vec&lt;String&gt;) -&gt; &amp;String {
    let s_ref = &amp;strings[0];
    s_ref`{}`
}
</code></pre>
<p>This snippet introduces a new kind of permission, the flow permission @Perm{flow}. The @Perm{flow} permission is expected whenever an expression uses an input reference (like <code>&amp;strings[0]</code>), or returns an output reference (like <code>return s_ref</code>).</p>
<p>Unlike the @Perm{read}@Perm{write}@Perm{own} permissions, @Perm{flow} does not change throughout the body of a function. A reference has the @Perm{flow} permission if it's allowed to be used (that is, to <em>flow</em>) in a particular expression. For example, let's say we change <code>first</code> to a new function <code>first_or</code> that includes a <code>default</code> parameter:</p>
<pre><code class="language-aquascope permissions boundaries showFlows shouldFail">fn first_or&lt;'a, 'b, 'c&gt;(strings: &amp;'a Vec&lt;String&gt;, default: &amp;'b String) -&gt; &amp;'c String {
    if strings.len() &gt; 0 {
        &amp;strings[0]`{}`
    } else {
        default`{}`
    }
}
</code></pre>
<p>This function no longer compiles, because the expressions <code>&amp;strings[0]</code> and <code>default</code> lack the necessary @Perm{flow} permission to be returned. But why? Rust gives the following error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; test.rs:1:57
  |
1 | fn first_or(strings: &amp;Vec&lt;String&gt;, default: &amp;String) -&gt; &amp;String {
  |                      ------------           -------     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `strings` or `default`
</code></pre>
<p>The message "missing lifetime specifier" is a bit mysterious, but the help message provides some useful context. If Rust <em>just</em> looks at the function signature, it doesn't know whether the output <code>&amp;String</code> is a reference to either <code>strings</code> or <code>default</code>. To understand why that matters, let's say we used <code>first_or</code> like this:</p>
<pre><code class="language-rust ignore">fn main() {
    let strings = vec![];
    let default = String::from("default");
    let s = first_or(&amp;strings, &amp;default);
    drop(default);
    println!("{}", s);
}</code></pre>
<p>This program is unsafe if <code>first_or</code> allows <code>default</code> to <em>flow</em> into the return value. Like the previous example, <code>drop</code> could invalidate <code>s</code>. Rust would only allow this program to compile if it was <em>certain</em> that <code>default</code> cannot flow into the return value.</p>
<p>To specify whether <code>default</code> can be returned, Rust provides a mechanism called <em>lifetime parameters</em>. We will explain that feature later in Chapter 10.3, <a href="ch10-03-lifetime-syntax.html">"Validating References with Lifetimes"</a>. For now, it's enough to know that: (1) input/output references are treated differently than references within a function body, and (2) Rust uses a different mechanism, the @Perm{flow} permission, to check the safety of those references.</p>
<p>To see the @Perm{flow} permission in another context, say you tried to return a reference to a variable on the stack like this:</p>
<pre><code class="language-aquascope permissions boundaries showFlows shouldFail">fn return_a_string() -&gt; &amp;String {
    let s = String::from("Hello world");
    let s_ref = &amp;s;
    s_ref`{}`
}
</code></pre>
<p>This program is unsafe because the reference <code>&amp;s</code> will be invalidated when <code>return_a_string</code> returns. And Rust will reject this program with a similar <code>missing lifetime specifier</code> error. Now you can understand that error means that <code>s_ref</code> is missing the appropriate flow permissions.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch04-02-references-sec3-safety&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Although `n` is marked as `mut`, the reference to `n` must also be marked as `mut`. \nSo a valid version of this program would say `incr(&amp;mut n)`.\n&quot;,&quot;id&quot;:&quot;5080616f-6f4c-43f7-aa3a-8b23f2798937&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:7},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn incr(n: &amp;mut i32) {\n  *n += 1;\n}\n\nfn main() {\n  let mut n = 1;\n  incr(&amp;n);\n  println!(\&quot;{n}\&quot;);\n}\n&quot;}},{&quot;context&quot;:&quot;It is illegal to use a mutable reference to a value (`s3`) while an immutable reference \nis live (`s2`).\n&quot;,&quot;id&quot;:&quot;e9846c5d-1254-4420-9986-dae4af86b9af&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:6},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn main() {\n  let mut s = String::from(\&quot;hello\&quot;);\n  let s2 = &amp;s;\n  let s3 = &amp;mut s;\n  s3.push_str(\&quot; world\&quot;);\n  println!(\&quot;{s2}\&quot;);\n}\n&quot;}},{&quot;context&quot;:&quot;As we saw earlier in the section, `v.push(n)` can cause `v` to reallocate its internal contents, invalidating any references to the elements of `v` on the heap.\nTherefore calling `give_and_take(&amp;v, 4)` will cause previously-created element references to point to invalid memory. The two programs that bind `let n = &amp;v[0]`\nbefore `give_and_take` are candidates for undefined behavior. `let v2 = &amp;v` is not a candidate because a reference to the container `v` is not actually invalidated \nby mutating `v`.\n\nThe program that does `println!(\&quot;{}\&quot;, n)` will cause undefined behavior by reading the invalid memory. The program that does `println!(\&quot;{}\&quot;, k)` will not cause undefined\nbehavior, because it does not use the invalidated reference.\n&quot;,&quot;id&quot;:&quot;80f6bcd6-b74a-4da3-a014-d423c82ce405&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;```\nlet v = vec![1, 2, 3];\nlet n = &amp;v[0];\ngive_and_take(&amp;v, 4);\nprintln!(\&quot;{}\&quot;, n);\n```\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\nlet v = vec![1, 2, 3];\nlet v2 = &amp;v;\ngive_and_take(&amp;v, 4);\nprintln!(\&quot;{}\&quot;, v2[0]);\n```\n&quot;,&quot;```\nlet v = vec![1, 2, 3];\nlet n = &amp;v[0];\nlet k = give_and_take(&amp;v, 4);\nprintln!(\&quot;{}\&quot;, k);\n```\n&quot;,&quot;None of these programs&quot;],&quot;prompt&quot;:&quot;Consider this Rust function that pushes a number onto the end of a vector, and then removes and returns the number from the front of the vector:\n\n```\nfn give_and_take(v: &amp;Vec&lt;i32&gt;, n: i32) -&gt; i32 {\n    v.push(n);\n    v.remove(0)\n}\n```\n\nNormally, if you try to compile this function, the compiler returns the following error:\n\n```text\nerror[E0596]: cannot borrow `*v` as mutable, as it is behind a `&amp;` reference\n --&gt; test.rs:2:5\n  |\n1 | fn give_and_take(v: &amp;Vec&lt;i32&gt;, n: i32) -&gt; i32 {\n  |                     --------- help: consider changing this to be a mutable reference: `&amp;mut Vec&lt;i32&gt;`\n2 |     v.push(n);\n  |     ^^^^^^^^^ `v` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable\n```\n\nAssume that the compiler did NOT reject this function. Select each (if any) of the following programs that could\npossibly cause undefined behavior if executed. If none of these programs could cause undefined behavior, \nthen check \&quot;None of these programs\&quot; .\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>References provide the ability to read and write data without consuming ownership of it. References are created with borrows (<code>&amp;</code> and <code>&amp;mut</code>) and used with dereferences (<code>*</code>), often implicitly.</p>
<p>However, references can be easily misused. Rust's borrow checker enforces a system of permissions that ensures references are used safely:</p>
<ul>
<li>All variables can read, own, and (optionally) write their data.</li>
<li>Creating a reference will transfer permissions from the borrowed place to the reference.</li>
<li>Permissions are returned once the reference's lifetime has ended.</li>
<li>Data must outlive all references that point to it.</li>
</ul>
<p>In this section, it probably feels like we've described more of what Rust <em>cannot</em> do than what Rust <em>can</em> do. That is intentional! One of Rust's core features is allowing you to use pointers without garbage collection, while also avoiding undefined behavior. Understanding these safety rules now will help you avoid frustration with the compiler later.</p>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css">
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-01-what-is-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-03-fixing-ownership-errors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-01-what-is-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-03-fixing-ownership-errors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="js-extensions/packages/telemetry/dist/index.js"></script>
        <script src="js-extensions/packages/feedback/dist/index.js"></script>



    </div>
    </body>
</html>
