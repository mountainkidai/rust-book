<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ownership Inventory #3 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="js-extensions/packages/feedback/dist/index.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/rust-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="ownership-inventory-3"><a class="header" href="#ownership-inventory-3">Ownership Inventory #3</a></h2>
<p>The Ownership Inventory is a series of quizzes that test your understanding of ownership in real-world scenarios. These scenarios are inspired by common StackOverflow questions about Rust.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch10-04-inventory&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The method `slice::sort` expects a mutable reference to a slice, but\ninstead gets an immutable reference.\n&quot;,&quot;id&quot;:&quot;9ff33b87-38e2-471b-8ca4-9c31a6431376&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;cannot borrow `elems` as mutable for `sort`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;cannot move out of shared reference for `clone`&quot;,&quot;cannot move out of shared reference in expression `&amp;elems[n]`&quot;,&quot;the lifetime of `T` must outlive `&amp;[T]`&quot;],&quot;prompt&quot;:&quot;**Program 1:**\n\n```ide\n/// Returns the n-th largest element in a slice\nfn find_nth&lt;T: Ord + Clone&gt;(elems: &amp;[T], n: usize) -&gt; T {\n    elems.sort();\n    let t = &amp;elems[n];\n    return t.clone();\n}\n```\n\nIf you tried to compile this program, which of the following best describes the compiler error you would get?\n&quot;}},{&quot;context&quot;:&quot;This program is technically memory-safe because `slice::sort` is only capable of moving\nelements around, not freeing them. For instance, `&amp;v[0]` is guaranteed to point to \n*some* number after calling `find_nth`, even if it is not the *original* number.\n\nNote that `find_nth(&amp;v, 10)` does not cause undefined behavior because Rust performs checks\non array accesses, so evaluating `&amp;v[10]` will panic.\n&quot;,&quot;id&quot;:&quot;3ee8d846-d282-4de1-8e83-5ca0bc44fc13&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;None of these programs&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\nlet v = vec![5, 4, 3, 2, 1];\nfind_nth(&amp;v, 10);\n```\n&quot;,&quot;```\nlet v = vec![5, 4, 3, 2, 1];\nfind_nth(&amp;v, 0);\nprintln!(\&quot;{}\&quot;, v[0]);\n```\n&quot;,&quot;```\nlet v = vec![5, 4, 3, 2, 1];\nlet n = &amp;v[0];\nfind_nth(&amp;v, 0);\nprintln!(\&quot;{}\&quot;, n);\n```\n&quot;],&quot;prompt&quot;:&quot;**Program 1:**\n\n```ide\n/// Returns the n-th largest element in a slice\nfn find_nth&lt;T: Ord + Clone&gt;(elems: &amp;[T], n: usize) -&gt; T {\n    elems.sort();\n    let t = &amp;elems[n];\n    return t.clone();\n}\n```\n\nNormally if you try to compile this function, the compiler returns the following error:\n\n```text\nerror[E0596]: cannot borrow `*elems` as mutable, as it is behind a `&amp;` reference\n --&gt; test.rs:3:5\n  |\n3 |     elems.sort();\n  |     ^^^^^^^^^^^^ `elems` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable\n```\n\nAssume that the compiler did NOT reject this function. Which (if any) of the following programs would\n(1) pass the compiler, and (2) possibly cause undefined behavior if executed?\nCheck each program that satisfies both criteria, OR check \&quot;None of these programs\&quot; if none are satisfying.\n&quot;}},{&quot;context&quot;:&quot;A function like `find_nth` is clearly intended to be a read-only function, i.e. to\nextract some property of the input sequence. Any solution which mutates or drops the input therefore does not preserve the original function's intention, even if\nit is more efficient than creating an auxiliary vector. \n\nCreating a `Vec&lt;&amp;T&gt;` is preferable to creating a `Vec&lt;T&gt;`, since if `T` is large, then\n`elems.to_vec()` could be expensive. However, if we knew that `T: Copy`, then `to_vec`\nwould be preferable to reduce the number of pointer dereferences within `elems.sort()`.\n&quot;,&quot;id&quot;:&quot;d070eb9e-4527-453a-8c9b-698739a3dd6a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```ide\nfn find_nth&lt;T: Ord + Clone&gt;(elems: &amp;[T], n: usize) -&gt; T {\n    `[let mut elem_refs: Vec&lt;&amp;T&gt; = elems.iter().collect();]`\n    `[elem_refs.sort();]`\n    let t = `[elem_refs[n]]`;\n    return t.clone();\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```ide\nfn find_nth&lt;T: Ord + Clone&gt;(`[elems: &amp;mut [T]]`, n: usize) -&gt; T {\n    elems.sort();\n    let t = &amp;elems[n];\n    return t.clone();\n}\n```\n&quot;,&quot;```ide\nfn find_nth&lt;T: Ord + Clone&gt;(elems: &amp;[T], n: usize) -&gt; T {\n    `[let mut elems = elems.to_vec();]`\n    elems.sort();\n    let t = &amp;elems[n];\n    return t.clone();\n}\n```\n&quot;,&quot;```ide\nfn find_nth&lt;`[T: Ord]`&gt;(`[mut elems: Vec&lt;T&gt;]`, n: usize) -&gt; T {\n    elems.sort();\n    let t = `[elems.remove(n)]`;\n    return `[t]`;\n}\n```\n&quot;],&quot;prompt&quot;:&quot;**Program 1:**\n\n```ide\n/// Returns the n-th largest element in a slice\nfn find_nth&lt;T: Ord + Clone&gt;(elems: &amp;[T], n: usize) -&gt; T {\n    elems.sort();\n    let t = &amp;elems[n];\n    return t.clone();\n}\n```\n\nOf the following fixes (highlighted in yellow), which fix best satisfies these three criteria:\n1. The fixed function passes the Rust compiler,\n2. The fixed function preserves the intention of the original code, and\n3. The fixed function does not introduce unnecessary inefficiencies\n&quot;}},{&quot;context&quot;:&quot;Due to lifetime elision, the function `get_curve` has the type signature `get_curve&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a Option&lt;usize&gt;`. \nThis means that a call to `self.get_curve()` extends the entire borrow on `self`, not just on `self.curve`.\nTherefore `self` is immutably borrowed inside the scope of `let Some(curve) = ...`, and `self.scores.iter_mut()`\ncannot be called.\n&quot;,&quot;id&quot;:&quot;95979d75-5823-4059-a1cf-7e0eba69b41a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;in `apply_curve`, cannot borrow `self.scores` as mutable for `iter_mut`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;in `get_curve`, cannot return a reference to a local variable `self.curve`&quot;,&quot;in `apply_curve`, cannot borrow `self` as immutable for `get_curve`&quot;,&quot;in `apply_curve`, `*score` cannot be mutated&quot;],&quot;prompt&quot;:&quot;**Program 2:**\n\n```ide\nstruct TestResult {\n    /// Student's scores on a test\n    scores: Vec&lt;usize&gt;,\n\n    /// A possible value to curve all scores\n    curve: Option&lt;usize&gt;\n}\nimpl TestResult {  \n    pub fn get_curve(&amp;self) -&gt; &amp;Option&lt;usize&gt; { \n        &amp;self.curve \n    }\n\n    /// If there is a curve, then increments all \n    /// scores by the curve\n    pub fn apply_curve(&amp;mut self) {\n        if let Some(curve) = self.get_curve() {\n            for score in self.scores.iter_mut() {\n                *score += *curve;\n            }\n        }\n    }\n}\n```\n\nIf you tried to compile this program, which of the following best describes the compiler error you would get?\n&quot;}},{&quot;context&quot;:&quot;This program is actually safe as written. It is a limitation of the borrow checker to not understand that `get_curve`\nonly borrows `curve`, and doesn't affect `scores`. However, in theory if `get_curve` were changed to return a reference\nto something with `self.scores`, then memory safety could potentially be violated.\n&quot;,&quot;id&quot;:&quot;dcb42a15-d9b7-437d-95ec-f000b64ce277&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;None of these programs&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\nlet mut result = TestResult { \n    scores: vec![20, 50, 30], \n    curve: Some(10) \n};\nresult.apply_curve();\n```\n&quot;,&quot;```\nlet mut result = TestResult { \n    scores: vec![20, 50, 30], \n    curve: Some(10) \n};\nlet x = &amp;result.scores[0];\nresult.apply_curve();\nprintln!(\&quot;{}\&quot;, x);\n```\n&quot;,&quot;```\nlet mut result = TestResult { \n    scores: vec![20, 50, 30], \n    curve: Some(10) \n};\nresult.apply_curve();\nprintln!(\&quot;{:?}\&quot;, result.scores);\n```\n&quot;],&quot;prompt&quot;:&quot;**Program 2:**\n\n```ide\nstruct TestResult {\n    /// Student's scores on a test\n    scores: Vec&lt;usize&gt;,\n\n    /// A possible value to curve all scores\n    curve: Option&lt;usize&gt;\n}\nimpl TestResult {  \n    pub fn get_curve(&amp;self) -&gt; &amp;Option&lt;usize&gt; { \n        &amp;self.curve \n    }\n\n    /// If there is a curve, then increments all \n    /// scores by the curve\n    pub fn apply_curve(&amp;mut self) {\n        if let Some(curve) = self.get_curve() {\n            for score in self.scores.iter_mut() {\n                *score += *curve;\n            }\n        }\n    }\n}\n```\n\nNormally if you try to compile this function, the compiler returns the following error:\n\n```text\nerror[E0502]: cannot borrow `self.scores` as mutable because it is also borrowed as immutable\n  --&gt; test.rs:17:26\n   |\n16 |         if let Some(curve) = self.get_curve() {\n   |                              ---------------- immutable borrow occurs here\n17 |             for score in self.scores.iter_mut() {\n   |                          ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n18 |                 *score += *curve;\n   |                           ------ immutable borrow later used here\n```\n\nAssume that the compiler did NOT reject this function. Which (if any) of the following programs would\n(1) pass the compiler, and (2) possibly cause undefined behavior if executed?\nCheck each program that satisfies both criteria, OR check \&quot;None of these programs\&quot; if none are satisfying.\n&quot;}},{&quot;context&quot;:&quot;By inlining the definition of `get_curve` into `apply_curve`, the borrow checker understands that `self.curve` is not `self.scores`,\nso it allows the function to compile. This is a common workaround for this type of borrow checker limitation.\n\nAnother option is to leverage the fact that `self.curve` is cheap to copy and use [`Option::copied`](https://doc.rust-lang.org/std/option/enum.Option.html#method.copied), \nwhich would release the borrow on `self` as soon as `.copied()` is called.\n&quot;,&quot;id&quot;:&quot;aa93c497-9864-4799-b69b-7de42c158f2a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```ide\npub fn apply_curve(&amp;mut self) {\n    if let Some(curve) = `[self.curve]` {\n        for score in self.scores.iter_mut() {\n            *score += curve;\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```ide\npub fn apply_curve(&amp;mut self) {\n    if let Some(curve) = self.get_curve()`[.as_ref()]` {\n        for score in self.scores.iter_mut() {\n            *score += *curve;\n        }\n    }\n}\n```\n&quot;,&quot;```ide\npub fn apply_curve(&amp;mut self) {\n    if let Some(curve) = self.get_curve() {\n        for score in self.scores`[.clone()]`.iter_mut() {\n            *score += *curve;\n        }\n    }\n}\n```\n&quot;,&quot;```ide\npub fn apply_curve(&amp;mut self) {\n    if let Some(curve) = self.get_curve() {\n        for score in self.scores`[.iter()]` {\n            *score += *curve;\n        }\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;**Program 2:**\n\n```ide\nstruct TestResult {\n    /// Student's scores on a test\n    scores: Vec&lt;usize&gt;,\n\n    /// A possible value to curve all scores\n    curve: Option&lt;usize&gt;\n}\nimpl TestResult {  \n    pub fn get_curve(&amp;self) -&gt; &amp;Option&lt;usize&gt; { \n        &amp;self.curve \n    }\n\n    /// If there is a curve, then increments all \n    /// scores by the curve\n    pub fn apply_curve(&amp;mut self) {\n        if let Some(curve) = self.get_curve() {\n            for score in self.scores.iter_mut() {\n                *score += *curve;\n            }\n        }\n    }\n}\n```\n\nOf the following fixes (highlighted in yellow), which fix best satisfies these three criteria:\n1. The fixed function passes the Rust compiler,\n2. The fixed function preserves the intention of the original code, and\n3. The fixed function does not introduce unnecessary inefficiencies\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css">
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-00-testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-03-lifetime-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-00-testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="js-extensions/packages/telemetry/dist/index.js"></script>
        <script src="js-extensions/packages/feedback/dist/index.js"></script>



    </div>
    </body>
</html>
