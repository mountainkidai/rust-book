<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fixing Ownership Errors - rfSE Club - rust Playground</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="js-extensions/packages/feedback/dist/index.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rfSE Club - rust Playground</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="http://github.com/mountainkidai/rust-book/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="fixing-ownership-errors"><a class="header" href="#fixing-ownership-errors">Fixing Ownership Errors</a></h2>
<p>Learning how to fix an ownership error is a core Rust skill. When the borrow checker rejects your code, how should you respond? In this section, we will discuss several case studies of common ownership errors. Each case study will present a function rejected by the compiler. Then we will explain why Rust rejects the function, and show several ways to fix it.</p>
<p>A common theme will be understanding whether a function is <em>actually</em> safe or unsafe. Rust will always reject an unsafe program<sup class="footnote-reference" id="fr-safe-subset-1"><a href="#footnote-safe-subset">1</a></sup>. But sometimes, Rust will also reject a safe program. These case studies will show how to respond to errors in both situations.</p>
<!-- The last two sections have shown how a Rust program can be **unsafe** if it triggers undefined behavior. The ownership guarantee is that Rust will reject all unsafe programs. However, Rust will also reject *some* safe programs. Fixing an ownership error will depend on whether your program is *actually* safe or unsafe. -->
<h3 id="fixing-an-unsafe-program-returning-a-reference-to-the-stack"><a class="header" href="#fixing-an-unsafe-program-returning-a-reference-to-the-stack">Fixing an Unsafe Program: Returning a Reference to the Stack</a></h3>
<p>Our first case study is about returning a reference to the stack, just like we discussed last section in <a href="ch04-02-references-and-borrowing.html#data-must-outlive-all-of-its-references">"Data Must Outlive All Of Its References"</a>. Here's the function we looked at:</p>
<pre><code class="language-rust ignore does_not_compile">fn return_a_string() -&gt; &amp;String {
    let s = String::from("Hello world");
    &amp;s
}</code></pre>
<p>When thinking about how to fix this function, we need to ask: <strong>why is this program unsafe?</strong> Here, the issue is with the lifetime of the referred data. If you want to pass around a reference to a string, you have to make sure that the underlying string lives long enough.</p>
<p>Depending on the situation, here are four ways you can extend the lifetime of the string. One is to move ownership of the string out of the function, changing <code>&amp;String</code> to <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_a_string() -&gt; String {
    let s = String::from("Hello world");
    s
}
<span class="boring">}</span></code></pre></pre>
<p>Another possibility is to return a string literal, which lives forever (indicated by <code>'static</code>). This solution applies if we never intend to change the string, and then a heap allocation is unnecessary:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_a_string() -&gt; &amp;'static str {
    "Hello world"    
}
<span class="boring">}</span></code></pre></pre>
<p>Another possibility is to defer borrow-checking to runtime by using garbage collection. For example, you can use a <a href="https://doc.rust-lang.org/std/rc/index.html">reference-counted pointer</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
fn return_a_string() -&gt; Rc&lt;String&gt; {
    let s = Rc::new(String::from("Hello world"));
    Rc::clone(&amp;s)
}
<span class="boring">}</span></code></pre></pre>
<p>We will discuss reference-counting more in Chapter 15.4 <a href="ch15-04-rc.html">"<code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer"</a>. In short, <code>Rc::clone</code> only clones a pointer to <code>s</code> and not the data itself. At runtime, the <code>Rc</code> checks when the last <code>Rc</code> pointing to data has been dropped, and then deallocates the data.</p>
<p>Yet another possibility is to have the caller provide a "slot" to put the string using a mutable reference:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_a_string(output: &amp;mut String) {
    output.replace_range(.., "Hello world");
}
<span class="boring">}</span></code></pre></pre>
<p>With this strategy, the caller is responsible for creating space for the string. This style can be verbose, but it can also be more memory-efficient if the caller needs to carefully control when allocations occur.</p>
<p>Which strategy is most appropriate will depend on your application. But the key idea is to recognize the root issue underlying the surface-level ownership error. How long should my string live? Who should be in charge of deallocating it? Once you have a clear answer to those questions, then it's a matter of changing your API to match.</p>
<h3 id="fixing-an-unsafe-program-not-enough-permissions"><a class="header" href="#fixing-an-unsafe-program-not-enough-permissions">Fixing an Unsafe Program: Not Enough Permissions</a></h3>
<p>Another common issue is trying to mutate read-only data, or trying to drop data behind a reference. For example, let's say we tried to write a function <code>stringify_name_with_title</code>. This function is supposed to create a person's full name from a vector of name parts, including an extra title.</p>
<pre><code class="language-aquascope permissions stepper boundaries shouldFail">fn stringify_name_with_title(name: &amp;Vec&lt;String&gt;) -&gt; String {
    name.push(String::from("Esq."));`{}`
    let full = name.join(" ");
    full
}

// ideally: ["Ferris", "Jr."] =&gt; "Ferris Jr. Esq."
</code></pre>
<p>This program is rejected by the borrow checker because <code>name</code> is an immutable reference, but <code>name.push(..)</code> requires the @Perm{write} permission. This program is unsafe because <code>push</code> could invalidate other references to <code>name</code> outside of <code>stringify_name_with_title</code>, like this:</p>
<pre><code class="language-aquascope interpreter shouldFail horizontal">#fn stringify_name_with_title(name: &amp;Vec&lt;String&gt;) -&gt; String {
#    name.push(String::from("Esq."));
#    let full = name.join(" ");
#    full
#}
fn main() {
    let name = vec![String::from("Ferris")];
    let first = &amp;name[0];`[]`
    stringify_name_with_title(&amp;name);`[]`
    println!("{}", first);`[]`
}
</code></pre>
<p>In this example, a reference <code>first</code> to <code>name[0]</code> is created before calling <code>stringify_name_with_title</code>. The function <code>name.push(..)</code> reallocates the contents of <code>name</code>, which invalidates <code>first</code>, causing the <code>println</code> to read deallocated memory.</p>
<p>So how do we fix this API? One straightforward solution is to change the type of name from <code>&amp;Vec&lt;String&gt;</code> to <code>&amp;mut Vec&lt;String&gt;</code>:</p>
<pre><code class="language-rust ignore">fn stringify_name_with_title(name: &amp;mut Vec&lt;String&gt;) -&gt; String {
    name.push(String::from("Esq."));
    let full = name.join(" ");
    full
}</code></pre>
<p>But this is not a good solution! <strong>Functions should not mutate their inputs if the caller would not expect it.</strong> A person calling <code>stringify_name_with_title</code> probably does not expect their vector to be modified by this function. Another function like <code>add_title_to_name</code> might be expected to mutate its input, but not our function.</p>
<p>Another option is to take ownership of the name, by changing <code>&amp;Vec&lt;String&gt;</code> to <code>Vec&lt;String&gt;</code>:</p>
<pre><code class="language-rust ignore">fn stringify_name_with_title(mut name: Vec&lt;String&gt;) -&gt; String {
    name.push(String::from("Esq."));
    let full = name.join(" ");
    full
}</code></pre>
<p>But this is also not a good solution! <strong>It is very rare for Rust functions to take ownership of heap-owning data structures like <code>Vec</code> and <code>String</code>.</strong>  This version of <code>stringify_name_with_title</code> would make the input <code>name</code> unusable, which is very annoying to a caller as we discussed at the beginning of <a href="ch04-02-references-and-borrowing.html">"References and Borrowing"</a>.</p>
<p>So the choice of <code>&amp;Vec</code> is actually a good one, which we do <em>not</em> want to change. Instead, we can change the body of the function. There are many possible fixes which vary in how much memory they use. One possibility is to clone the input <code>name</code>:</p>
<pre><code class="language-rust ignore">fn stringify_name_with_title(name: &amp;Vec&lt;String&gt;) -&gt; String {
    let mut name_clone = name.clone();
    name_clone.push(String::from("Esq."));
    let full = name_clone.join(" ");
    full
}</code></pre>
<p>By cloning <code>name</code>, we are allowed to mutate the local copy of the vector. However, the clone copies every string in the input. We can avoid unnecessary copies by adding the suffix later:</p>
<pre><code class="language-rust ignore">fn stringify_name_with_title(name: &amp;Vec&lt;String&gt;) -&gt; String {
    let mut full = name.join(" ");
    full.push_str(" Esq.");
    full
}</code></pre>
<p>This solution works because <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.join"><code>slice::join</code></a> already copies the data in <code>name</code> into the string <code>full</code>.</p>
<p>In general, writing Rust functions is a careful balance of asking for the <em>right</em> level of permissions. For this example, it's most idiomatic to only expect the read permission on <code>name</code>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch04-03-fixing-ownership-errors-sec1-idioms&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;A stack frame cannot have its lifetime extended, so that is not a valid solution.\n&quot;,&quot;id&quot;:&quot;8c9f9173-c5ba-4914-9cfa-e3432f8414e1&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Extend the lifetime of the stack frame&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Use a reference-counted pointer&quot;,&quot;Take ownership of the returned value&quot;,&quot;Expect a mutable slot from the caller&quot;],&quot;prompt&quot;:&quot;Which of the following is NOT a valid kind of fix to the issue of returning a stack reference from a function?\n&quot;}},{&quot;context&quot;:&quot;The function is not intended to change someone's original name, so changing the type of `name` to either `&amp;mut String` or `String` \nwould be inappropriate. The solution proposed by the compiler of `&amp;*name` is not sufficient --- an acceptable solution is to \nclone the data with `name.clone()` and mutate the local copy.\n&quot;,&quot;id&quot;:&quot;e6bc84ef-069c-4d1d-99ec-69b13492569c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```\nfn award_phd(name: &amp;String) -&gt; String {\n    let mut name = `[name.clone()]`;\n    name.push_str(\&quot;, Ph.D.\&quot;);\n    name\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\nfn award_phd(name: &amp;String) -&gt; String {\n    let mut name = `[&amp;*name]`;\n    name.push_str(\&quot;, Ph.D.\&quot;);\n    name\n}\n```\n&quot;,&quot;```\nfn award_phd(`[mut name: String]`) -&gt; String {\n    name.push_str(\&quot;, Ph.D.\&quot;);\n    name\n}\n```\n&quot;,&quot;```\nfn award_phd(`[name: &amp;mut String]`) {\n    name.push_str(\&quot;, Ph.D.\&quot;);\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Let's say a programmer tried writing the following function:\n\n```\n/// Returns a person's name with \&quot;Ph.D.\&quot; added as a title\nfn award_phd(name: &amp;String) -&gt; String {\n    let mut name = *name;\n    name.push_str(\&quot;, Ph.D.\&quot;);\n    name\n}\n```\n\nThe Rust compiler rejects their code with the following error:\n\n```text\nerror[E0507]: cannot move out of `*name` which is behind a shared reference\n --&gt; test.rs:3:20\n  |\n3 |     let mut name = *name;\n  |                    ^^^^^\n  |                    |\n  |                    move occurs because `*name` has type `String`, which does not implement the `Copy` trait\n  |                    help: consider borrowing here: `&amp;*name`\n```\n\nGiven the stated purpose of the function, which of the following would be the most idiomatic fix to the program? \nThe differences from the function above are highlighted.\n&quot;}},{&quot;context&quot;:&quot;Because this function is supposed to round a vector in-place, it would not be\nidiomatic to return a new copy of the same vector (`-&gt; Vec&lt;f32&gt;`) or to consume\nownership of the vector (`mut v: Vec&lt;f32&gt;`). The best solution is to change \nthe type signature from `&amp;Vec&lt;f32&gt;` to `&amp;mut Vec&lt;f32&gt;`.\n&quot;,&quot;id&quot;:&quot;8020e4a2-f0b4-4eae-90ac-a87712d9d00b&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```\nfn round_in_place(v: `[&amp;mut Vec&lt;f32&gt;]`) {\n    for n in v {\n        *n = n.round();\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\nfn round_in_place(v: &amp;Vec&lt;f32&gt;) `[-&gt; Vec&lt;f32&gt;]` {\n    `[let mut v2 = Vec::new();]`\n    for n in v {\n        `[v2.push(n.round());]`\n    }\n    `[v2]`\n}\n```\n&quot;,&quot;```\nfn round_in_place(`[mut v: Vec&lt;f32&gt;]`) {\n    for n in v {\n        *n = n.round();\n    }    \n}\n```\n&quot;,&quot;```\nfn round_in_place(v: &amp;Vec&lt;f32&gt;) {\n    for `[mut n]` in `[&amp;mut v.clone()]` {\n        n = n.round();\n    }    \n}\n```\n&quot;],&quot;prompt&quot;:&quot;Let's say a programmer tried writing the following function:\n\n```\n/// Rounds all the floats in a vector to the nearest integer, in-place\nfn round_in_place(v: &amp;Vec&lt;f32&gt;) {\n    for n in v {\n        *n = n.round();\n    }\n}\n```\n\nThe Rust compiler rejects their code with the following error:\n\n```text\nerror[E0594]: cannot assign to `*n`, which is behind a `&amp;` reference\n --&gt; test.rs:4:9\n  |\n3 |     for n in v {\n  |              - this iterator yields `&amp;` references\n4 |         *n = n.round();\n  |         ^^^^^^^^^^^^^^ `n` is a `&amp;` reference, so the data it refers to cannot be written\n```\n\nGiven the stated purpose of the function, which of the following would be the most idiomatic fix to the program? \nThe differences from the function above are highlighted.\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h3 id="fixing-an-unsafe-program-aliasing-and-mutating-a-data-structure"><a class="header" href="#fixing-an-unsafe-program-aliasing-and-mutating-a-data-structure">Fixing an Unsafe Program: Aliasing and Mutating a Data Structure</a></h3>
<p>Another unsafe operation is using a reference to heap data that gets deallocated by another alias. For example, here's a function that gets a reference to the largest string in a vector, and then uses it while mutating the vector:</p>
<pre><code class="language-aquascope permissions stepper boundaries shouldFail">fn add_big_strings(dst: &amp;mut Vec&lt;String&gt;, src: &amp;[String]) {`(focus,paths:*dst)`
    let largest: &amp;String = 
      dst.iter().max_by_key(|s| s.len()).unwrap();`(focus,paths:*dst)`
    for s in src {
        if s.len() &gt; largest.len() {
            dst.push(s.clone());`{}`
        }
    }
}
</code></pre>
<blockquote>
<p><em>Note:</em> this example uses <a href="ch13-02-iterators.html">iterators</a> and <a href="ch13-01-closures.html">closures</a> to succinctly find a reference to the largest string. We will discuss those features in later chapters, and for now we will provide an intuitive sense of how the features work here.</p>
</blockquote>
<p>This program is rejected by the borrow checker because <code>let largest = ..</code> removes the @Perm{write} permissions on <code>dst</code>. However, <code>dst.push(..)</code> requires the @Perm{write} permission. Again, we should ask: <strong>why is this program unsafe?</strong> Because <code>dst.push(..)</code> could deallocate the contents of <code>dst</code>, invalidating the reference <code>largest</code>.</p>
<p>To fix the program, the key insight is that we need to shorten the lifetime of <code>largest</code> to not overlap with <code>dst.push(..)</code>. One possibility is to clone <code>largest</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_big_strings(dst: &amp;mut Vec&lt;String&gt;, src: &amp;[String]) {
    let largest: String = dst.iter().max_by_key(|s| s.len()).unwrap().clone();
    for s in src {
        if s.len() &gt; largest.len() {
            dst.push(s.clone());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>However, this may cause a performance hit for allocating and copying the string data.</p>
<p>Another possibility is to perform all the length comparisons first, and then mutate <code>dst</code> afterwards:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_big_strings(dst: &amp;mut Vec&lt;String&gt;, src: &amp;[String]) {
    let largest: &amp;String = dst.iter().max_by_key(|s| s.len()).unwrap();
    let to_add: Vec&lt;String&gt; = 
        src.iter().filter(|s| s.len() &gt; largest.len()).cloned().collect();
    dst.extend(to_add);
}
<span class="boring">}</span></code></pre></pre>
<p>However, this also causes a performance hit for allocating the vector <code>to_add</code>.</p>
<p>A final possibility is to copy out the length of <code>largest</code>, since we don't actually need the contents of <code>largest</code>, just its length.
This solution is arguably the most idiomatic and the most performant:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_big_strings(dst: &amp;mut Vec&lt;String&gt;, src: &amp;[String]) {
    let largest_len: usize = dst.iter().max_by_key(|s| s.len()).unwrap().len();
    for s in src {
        if s.len() &gt; largest_len {
            dst.push(s.clone());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>These solutions all share in common the key idea: shortening the lifetime of borrows on <code>dst</code> to not overlap with a mutation to <code>dst</code>.</p>
<h3 id="fixing-an-unsafe-program-copying-vs-moving-out-of-a-collection"><a class="header" href="#fixing-an-unsafe-program-copying-vs-moving-out-of-a-collection">Fixing an Unsafe Program: Copying vs. Moving Out of a Collection</a></h3>
<p>A common confusion for Rust learners happens when copying data out of a collection, like a vector. For example, here's a safe program that copies a number out of a vector:</p>
<pre><code class="language-aquascope permissions stepper boundaries">#fn main() {
let v: Vec&lt;i32&gt; = vec![0, 1, 2];
let n_ref: &amp;i32 = &amp;v[0];`(focus,paths:*n_ref)`
let n: i32 = *n_ref;`{}`
#}
</code></pre>
<p>The dereference operation <code>*n_ref</code> expects just the @Perm{read} permission, which the path <code>*n_ref</code> has. But what happens if we change the type of elements in the vector from <code>i32</code> to <code>String</code>? Then it turns out we no longer have the necessary permissions:</p>
<pre><code class="language-aquascope permissions stepper boundaries shouldFail">#fn main() {
let v: Vec&lt;String&gt; = 
  vec![String::from("Hello world")];
let s_ref: &amp;String = &amp;v[0];`(focus,paths:*s_ref)`
let s: String = *s_ref;`[]``{}`
#}
</code></pre>
<p>The first program will compile, but the second program will not compile. Rust gives the following error message:</p>
<pre><code class="language-text">error[E0507]: cannot move out of `*s_ref` which is behind a shared reference
 --&gt; test.rs:4:9
  |
4 | let s = *s_ref;
  |         ^^^^^^
  |         |
  |         move occurs because `*s_ref` has type `String`, which does not implement the `Copy` trait
</code></pre>
<p>The issue is that the vector <code>v</code> owns the string "Hello world". When we dereference <code>s_ref</code>, that tries to take ownership of the string from the vector. But references are non-owning pointers — we can't take ownership <em>through</em> a reference. Therefore Rust complains that we "cannot move out of [...] a shared reference".</p>
<p>But why is this unsafe? We can illustrate the problem by simulating the rejected program:</p>
<pre><code class="language-aquascope interpreter shouldFail horizontal">#fn main() {
let v: Vec&lt;String&gt; = 
  vec![String::from("Hello world")];
let s_ref: &amp;String = &amp;v[0];`(focus,paths:*s_ref)`
let s: String = *s_ref;`[]``{}`

// These drops are normally implicit, but we've added them for clarity.
drop(s);`[]`
drop(v);`[]`
#}
</code></pre>
<p>What happens here is a <strong>double-free.</strong> After executing <code>let s = *s_ref</code>, both <code>v</code> and <code>s</code> think they own "Hello world". After <code>s</code> is dropped, "Hello world" is deallocated. Then <code>v</code> is dropped, and undefined behavior happens when the string is freed a second time.</p>
<blockquote>
<p><em>Note:</em> after executing <code>s = *s_ref</code>, we don't even have to use <code>v</code> or <code>s</code> to cause undefined behavior through the double-free. As soon as we move the string out from <code>s_ref</code>, undefined behavior will happen once the elements are dropped.</p>
</blockquote>
<p>However, this undefined behavior does not happen when the vector contains <code>i32</code> elements. The difference is that copying a <code>String</code> copies a pointer to heap data. Copying an <code>i32</code> does not.
In technical terms, Rust says that the type <code>i32</code> implements the <code>Copy</code> trait, while <code>String</code> does not implement <code>Copy</code> (we will discuss traits in a later chapter).</p>
<p>In sum, <strong>if a value does not own heap data, then it can be copied without a move.</strong> For example:</p>
<ul>
<li>An <code>i32</code> <strong>does not</strong> own heap data, so it <strong>can</strong> be copied without a move.</li>
<li>A <code>String</code> <strong>does</strong> own heap data, so it <strong>can not</strong> be copied without a move.</li>
<li>An <code>&amp;String</code> <strong>does not</strong> own heap data, so it <strong>can</strong> be copied without a move.</li>
</ul>
<blockquote>
<p><em>Note:</em> One exception to this rule is mutable references. For example, <code>&amp;mut i32</code> is not a copyable type. So if you do something like:</p>
<pre><code class="language-rust ignore">let mut n = 0;
let a = &amp;mut n;
let b = a;</code></pre>
<p>Then <code>a</code> cannot be used after being assigned to <code>b</code>. That prevents two mutable references to the same data from being used at the same time.</p>
</blockquote>
<p>So if we have a vector of non-<code>Copy</code> types like <code>String</code>, then how do we safely get access to an element of the vector? Here's a few different ways to safely do so. First, you can avoid taking ownership of the string and just use an immutable reference:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>let v: Vec&lt;String&gt; = vec![String::from("Hello world")];
let s_ref: &amp;String = &amp;v[0];
println!("{s_ref}!");
<span class="boring">}</span></code></pre>
<p>Second, you can clone the data if you want to get ownership of the string while leaving the vector alone:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>let v: Vec&lt;String&gt; = vec![String::from("Hello world")];
let mut s: String = v[0].clone();
s.push('!');
println!("{s}");
<span class="boring">}</span></code></pre>
<p>Finally, you can use a method like <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.remove"><code>Vec::remove</code></a> to move the string out of the vector:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>let mut v: Vec&lt;String&gt; = vec![String::from("Hello world")];
let mut s: String = v.remove(0);
s.push('!');
println!("{s}");
assert!(v.len() == 0);
<span class="boring">}</span></code></pre>
<h3 id="fixing-a-safe-program-mutating-different-tuple-fields"><a class="header" href="#fixing-a-safe-program-mutating-different-tuple-fields">Fixing a Safe Program: Mutating Different Tuple Fields</a></h3>
<p>The above examples are cases where a program is unsafe. Rust may also reject safe programs. One common issue is that Rust tries to track permissions at a fine-grained level. However, Rust may conflate two different places as the same place.</p>
<p>Let's first look at an example of fine-grained permission tracking that passes the borrow checker. This program shows how you can borrow one field of a tuple, and write to a different field of the same tuple:</p>
<pre><code class="language-aquascope permissions stepper boundaries">#fn main() {
let mut name = (
    String::from("Ferris"), 
    String::from("Rustacean")
);`(focus,paths:name)`
let first = &amp;name.0;`(focus,paths:name)`
name.1.push_str(", Esq.");`{}`
println!("{first} {}", name.1);
#}
</code></pre>
<p>The statement <code>let first = &amp;name.0</code> borrows <code>name.0</code>. This borrow removes @Perm{write}@Perm{own} permissions from <code>name.0</code>. It also removes @Perm{write}@Perm{own} permissions from <code>name</code>. (For example, one could not pass <code>name</code> to a function that takes as input a value of type <code>(String, String)</code>.) But <code>name.1</code> still retains the @Perm{write} permission, so doing <code>name.1.push_str(...)</code> is a valid operation.</p>
<p>However, Rust can lose track of exactly which places are borrowed. For example, let's say we refactor the expression <code>&amp;name.0</code> into a function <code>get_first</code>. Notice how after calling <code>get_first(&amp;name)</code>, Rust now removes the @Perm{write} permission on <code>name.1</code>:</p>
<pre><code class="language-aquascope permissions stepper boundaries shouldFail">fn get_first(name: &amp;(String, String)) -&gt; &amp;String {
    &amp;name.0
}

fn main() {
    let mut name = (
        String::from("Ferris"), 
        String::from("Rustacean")
    );
    let first = get_first(&amp;name);`(focus,paths:name)`
    name.1.push_str(", Esq.");`{}`
    println!("{first} {}", name.1);
}
</code></pre>
<p>Now we can't do <code>name.1.push_str(..)</code>! Rust will return this error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `name.1` as mutable because it is also borrowed as immutable
  --&gt; test.rs:11:5
   |
10 |     let first = get_first(&amp;name);
   |                           ----- immutable borrow occurs here
11 |     name.1.push_str(", Esq.");
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
12 |     println!("{first} {}", name.1);
   |                ----- immutable borrow later used here
</code></pre>
<p>That's strange, since the program was safe before we edited it. The edit we made doesn't meaningfully change the runtime behavior. So why does it matter that we put <code>&amp;name.0</code> into a function?</p>
<p>The problem is that Rust doesn't look at the implementation of <code>get_first</code> when deciding what <code>get_first(&amp;name)</code> should borrow. Rust only looks at the type signature, which just says "some <code>String</code> in the input gets borrowed". Rust conservatively decides then that both <code>name.0</code> and <code>name.1</code> get borrowed, and eliminates write and own permissions on both.</p>
<p>Remember, the key idea is that <strong>the program above is safe.</strong> It has no undefined behavior! A future version of Rust may be smart enough to let it compile, but for today, it gets rejected. So how should we work around the borrow checker today? One possibility is to inline the expression <code>&amp;name.0</code>, like in the original program. Another possibility is to defer borrow checking to runtime with <a href="https://doc.rust-lang.org/std/cell/index.html">cells</a>, which we will discuss in future chapters.</p>
<h3 id="fixing-a-safe-program-mutating-different-array-elements"><a class="header" href="#fixing-a-safe-program-mutating-different-array-elements">Fixing a Safe Program: Mutating Different Array Elements</a></h3>
<p>A similar kind of problem arises when we borrow elements of an array. For example, observe what places are borrowed when we take a mutable reference to an array:</p>
<pre><code class="language-aquascope permissions stepper boundaries">#fn main() {
let mut a = [0, 1, 2, 3];
let x = &amp;mut a[1];`(focus,paths:a[_])`
*x += 1;`(focus,paths:a[_])`
println!("{a:?}");
#}
</code></pre>
<p>Rust's borrow checker does not contain different places for <code>a[0]</code>, <code>a[1]</code>, and so on. It uses a single place <code>a[_]</code> that represents <em>all</em> indexes of <code>a</code>. Rust does this because it cannot always determine the value of an index. For example, imagine a more complex scenario like this:</p>
<pre><code class="language-rust ignore">let idx = a_complex_function();
let x = &amp;mut a[idx];</code></pre>
<p>What is the value of <code>idx</code>? Rust isn't going to guess, so it assumes <code>idx</code> could be anything. For example, let's say we try to read from one array index while writing to a different one:</p>
<pre><code class="language-aquascope permissions boundaries stepper shouldFail">#fn main() {
let mut a = [0, 1, 2, 3];
let x = &amp;mut a[1];`(focus,paths:a[_])`
let y = &amp;a[2];`{}`
*x += *y;
#}
</code></pre>
<p>However, Rust will reject this program because <code>a</code> gave its read permission to <code>x</code>. The compiler's error message says the same thing:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `a[_]` as immutable because it is also borrowed as mutable
 --&gt; test.rs:4:9
  |
3 | let x = &amp;mut a[1];
  |         --------- mutable borrow occurs here
4 | let y = &amp;a[2];
  |         ^^^^^ immutable borrow occurs here
5 | *x += *y;
  | -------- mutable borrow later used here
</code></pre>
<!-- However, Rust will reject this program because `a` gave its read permission to `x`. -->
<p>Again, <strong>this program is safe.</strong> For cases like these, Rust often provides a function in the standard library that can work around the borrow checker. For example, we could use <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut"><code>slice::split_at_mut</code></a>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>let mut a = [0, 1, 2, 3];
let (a_l, a_r) = a.split_at_mut(2);
let x = &amp;mut a_l[1];
let y = &amp;a_r[0];
*x += *y;
<span class="boring">}</span></code></pre>
<p>You might wonder, but how is <code>split_at_mut</code> implemented? In some Rust libraries, especially core types like <code>Vec</code> or <code>slice</code>, you will often find <strong><code>unsafe</code> blocks</strong>. <code>unsafe</code> blocks allow the use of "raw" pointers, which are not checked for safety by the borrow checker. For example, we could use an unsafe block to accomplish our task:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>let mut a = [0, 1, 2, 3];
let x = &amp;mut a[1] as *mut i32;
let y = &amp;a[2] as *const i32;
unsafe { *x += *y; } // DO NOT DO THIS unless you know what you're doing!
<span class="boring">}</span></code></pre>
<p>Unsafe code is sometimes necessary to work around the limitations of the borrow checker. As a general strategy, let's say the borrow checker rejects a program you think is actually safe. Then you should look for standard library functions (like <code>split_at_mut</code>) that contain <code>unsafe</code> blocks which solve your problem. We will discuss unsafe code further in <a href="ch19-01-unsafe-rust.html">Chapter 20</a>. For now, just be aware that unsafe code is how Rust implements certain otherwise-impossible patterns.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch04-03-fixing-ownership-errors-sec2-safety&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;If a `String` could be copied without a move, then two variables could think they own\nthe same string, leading to a double-free.\n&quot;,&quot;id&quot;:&quot;cbe8ef63-4f7e-45fd-b11f-e6eba40587b0&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;A `String` owns data on the heap, while an `i32` does not&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;An `i32` is smaller in memory than a `String`&quot;,&quot;An `i32` is a primitive type in Rust, while a `String` is not&quot;,&quot;A `String` can be placed on the heap, while an `i32` can only be placed on the stack&quot;],&quot;prompt&quot;:&quot;Which of the following best explains why an `i32` can be copied without a move, but a `String` cannot?\n&quot;}},{&quot;context&quot;:&quot;The `println` is technically safe, since the string won't be deallocated until the end\nof the current scope. But then undefined behavior occurs, when the string is freed twice\non behalf of `s` and `s2`.\n&quot;,&quot;id&quot;:&quot;512e1ec0-cd7b-4a90-949b-d7b08b4009a8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The string is freed twice at the end of the program&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;The read of `s2` in `println` is a use of freed memory&quot;,&quot;The dereference `*s_ref` is a use of freed memory&quot;,&quot;There is no undefined behavior in this program&quot;],&quot;prompt&quot;:&quot;The following code snippet does not compile:\n\n```rust\nlet s = String::from(\&quot;Hello world\&quot;);\nlet s_ref = &amp;s;\nlet s2 = *s_ref;\nprintln!(\&quot;{s2}\&quot;);\n```\n\nWhich of the following best describes the undefined behavior that could occur if this program were allowed to execute?\n&quot;}},{&quot;context&quot;:&quot;This program is safe. No undefined behavior could occur if it were executed. (If `i` was outside\nthe bounds of `v`, then Rust will panic at runtime rather than cause undefined behavior.)\n\nThe issue is that Rust doesn't know for sure that `v[i]` and `v[i - 1]` are referring to different elements.\n&quot;,&quot;id&quot;:&quot;1e31e163-5bd4-4385-b222-33c19058bf6a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;There is no undefined behavior in this program&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;The assignment `*n` is a use of freed memory&quot;,&quot;The borrow `&amp;mut v[i]` creates a pointer to freed memory&quot;,&quot;The read of `v[i - 1]` is a use of freed memory&quot;],&quot;prompt&quot;:&quot;The following program does not compile:\n\n```rust\nfn copy_to_prev(v: &amp;mut Vec&lt;i32&gt;, i: usize) {\n  let n = &amp;mut v[i];\n  *n = v[i - 1];\n}\nfn main() {\n  let mut v = vec![1, 2, 3];\n  copy_to_prev(&amp;mut v, 1);\n}\n```\n\nWhich of the following best describes the undefined behavior that could occur if this program were allowed to execute?\n&quot;}},{&quot;context&quot;:&quot;The statement `let mut name = *name` makes `name` take ownership of the input string.\nHowever, the caller also still retains ownership of the string. Therefore after `award_phd`\nfinishes, the string is deallocated. Therefore every program above has undefined behavior, \nbecause `name` will eventually be deallocated a second time. It does not matter whether `name`\nor a reference to `name` is read after calling `award_phd`.\n&quot;,&quot;id&quot;:&quot;4df75888-2cd5-4259-8629-46a307429fd0&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;```\nlet name = String::from(\&quot;Ferris\&quot;);\naward_phd(&amp;name);\n```\n&quot;,&quot;```\nlet name = String::from(\&quot;Ferris\&quot;);\naward_phd(&amp;name);\nprintln!(\&quot;{}\&quot;, name);\n```\n&quot;,&quot;```\nlet name = String::from(\&quot;Ferris\&quot;);\nlet name_ref = &amp;name;\naward_phd(&amp;name);\nprintln!(\&quot;{}\&quot;, name_ref);\n```\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;None of these programs&quot;],&quot;prompt&quot;:&quot;Consider this function that is a simplified variant of the function from the previous quiz:\n\n```\n/// Adds \&quot;Ph.D.\&quot; to a person's name\nfn award_phd(name: &amp;String) {\n    let mut name = *name;\n    name.push_str(\&quot;, Ph.D.\&quot;);\n}\n```\n\nThe Rust compiler rejects this function with the following error:\n\n```text\nerror[E0507]: cannot move out of `*name` which is behind a shared reference\n --&gt; test.rs:3:20\n  |\n3 |     let mut name = *name;\n  |                    ^^^^^\n  |                    |\n  |                    move occurs because `*name` has type `String`, which does not implement the `Copy` trait\n  |                    help: consider borrowing here: `&amp;*name`\n```\n\nAssume that the compiler did NOT reject this function. Select each (if any) of the following programs that could\npossibly cause undefined behavior if executed. If none of these programs could cause undefined behavior, \nthen check \&quot;None of these programs\&quot; .\n&quot;}},{&quot;context&quot;:&quot;This program does compile, as the binding of `x` copies `point[0]`, allowing `y` to mutably borrow `point[1]`.\nThe mutation `x += 1` does not affect `point`, while the mutation `*y += 1` does, so the final result is `0 2`.\n&quot;,&quot;id&quot;:&quot;1f48fda5-afc6-440b-a9aa-53dc8d54efaa&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;0 2&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn main() {\n    let mut point = [0, 1];\n    let mut x = point[0];\n    let y = &amp;mut point[1];\n    x += 1;\n    *y += 1;\n    println!(\&quot;{} {}\&quot;, point[0], point[1]);\n}\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>When fixing an ownership error, you should ask yourself: is my program actually unsafe? If yes, then you need to understand the root cause of the unsafety. If no, then you need to understand the limitations of the borrow checker to work around them.</p>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css"><hr>
<ol class="footnote-definition"><li id="footnote-safe-subset">
<p>This guarantee applies for programs written in the "safe subset" of Rust. If you use <code>unsafe</code> code or invoke unsafe components (like calling a C library), then you must take extra care to avoid undefined behavior. <a href="#fr-safe-subset-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-04-slices.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-04-slices.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="js-extensions/packages/telemetry/dist/index.js"></script>
        <script src="js-extensions/packages/feedback/dist/index.js"></script>



    </div>
    </body>
</html>
