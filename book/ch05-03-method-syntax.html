<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Method Syntax - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="js-extensions/packages/feedback/dist/index.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="http://github.com/mountainkidai/rust-book/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h2>
<p><em>Methods</em> are similar to functions: we declare them with the <code>fn</code> keyword and a
name, they can have parameters and a return value, and they contain some code
that’s run when the method is called from somewhere else. Unlike functions,
methods are defined within the context of a struct (or an enum or a trait
object, which we cover in <a href="ch06-00-enums.html">Chapter 6</a><!-- ignore --> and <a href="ch18-02-trait-objects.html">Chapter
18</a><!-- ignore -->, respectively), and their first parameter is
always <code>self</code>, which represents the instance of the struct the method is being
called on.</p>
<h3 id="defining-methods"><a class="header" href="#defining-methods">Defining Methods</a></h3>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown
in Listing 5-13.</p>
<Listing number="5-13" file-name="src/main.rs" caption="Defining an `area` method on the `Rectangle` struct">
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}</code></pre></pre>
</Listing>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code>
(implementation) block for <code>Rectangle</code>. Everything within this <code>impl</code> block
will be associated with the <code>Rectangle</code> type. Then we move the <code>area</code> function
within the <code>impl</code> curly brackets and change the first (and in this case, only)
parameter to be <code>self</code> in the signature and everywhere within the body. In
<code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument,
we can instead use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code>
instance. The method syntax goes after an instance: we add a dot followed by
the method name, parentheses, and any arguments.</p>
<p>In the signature for <code>area</code>, we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code>.
The <code>&amp;self</code> is actually short for <code>self: &amp;Self</code>. Within an <code>impl</code> block, the
type <code>Self</code> is an alias for the type that the <code>impl</code> block is for. Methods must
have a parameter named <code>self</code> of type <code>Self</code> for their first parameter, so Rust
lets you abbreviate this with only the name <code>self</code> in the first parameter spot.
Note that we still need to use the <code>&amp;</code> in front of the <code>self</code> shorthand to
indicate that this method borrows the <code>Self</code> instance, just as we did in
<code>rectangle: &amp;Rectangle</code>. Methods can take ownership of <code>self</code>, borrow <code>self</code>
immutably, as we’ve done here, or borrow <code>self</code> mutably, just as they can any
other parameter.</p>
<p>We chose <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the function
version: we don’t want to take ownership, and we just want to read the data in
the struct, not write to it. If we wanted to change the instance that we’ve
called the method on as part of what the method does, we’d use <code>&amp;mut self</code> as
the first parameter. Having a method that takes ownership of the instance by
using just <code>self</code> as the first parameter is rare; this technique is usually
used when the method transforms <code>self</code> into something else and you want to
prevent the caller from using the original instance after the transformation.</p>
<p>The main reason for using methods instead of functions, in addition to
providing method syntax and not having to repeat the type of <code>self</code> in every
method’s signature, is for organization. We’ve put all the things we can do
with an instance of a type in one <code>impl</code> block rather than making future users
of our code search for capabilities of <code>Rectangle</code> in various places in the
library we provide.</p>
<p>Note that we can choose to give a method the same name as one of the struct’s
fields. For example, we can define a method on <code>Rectangle</code> that is also named
<code>width</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}</code></pre></pre>
</Listing>
<p>Here, we’re choosing to make the <code>width</code> method return <code>true</code> if the value in
the instance’s <code>width</code> field is greater than <code>0</code> and <code>false</code> if the value is
<code>0</code>: we can use a field within a method of the same name for any purpose. In
<code>main</code>, when we follow <code>rect1.width</code> with parentheses, Rust knows we mean the
method <code>width</code>. When we don’t use parentheses, Rust knows we mean the field
<code>width</code>.</p>
<p>Often, but not always, when we give a method the same name as a field we want
it to only return the value in the field and do nothing else. Methods like this
are called <em>getters</em>, and Rust does not implement them automatically for struct
fields as some other languages do. Getters are useful because you can make the
field private but the method public, and thus enable read-only access to that
field as part of the type’s public API. We will discuss what public and private
are and how to designate a field or method as public or private in <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">Chapter
7</a><!-- ignore -->.</p>
<h3 id="methods-with-more-parameters"><a class="header" href="#methods-with-more-parameters">Methods with More Parameters</a></h3>
<p>Let’s practice using methods by implementing a second method on the <code>Rectangle</code>
struct. This time we want an instance of <code>Rectangle</code> to take another instance
of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely
within <code>self</code> (the first <code>Rectangle</code>); otherwise, it should return <code>false</code>.
That is, once we’ve defined the <code>can_hold</code> method, we want to be able to write
the program shown in Listing 5-14.</p>
<Listing number="5-14" file-name="src/main.rs" caption="Using the as-yet-unwritten `can_hold` method">
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
</Listing>
<p>The expected output would look like the following because both dimensions of
<code>rect2</code> are smaller than the dimensions of <code>rect1</code>, but <code>rect3</code> is wider than
<code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>We know we want to define a method, so it will be within the <code>impl Rectangle</code>
block. The method name will be <code>can_hold</code>, and it will take an immutable borrow
of another <code>Rectangle</code> as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
<code>rect1.can_hold(&amp;rect2)</code> passes in <code>&amp;rect2</code>, which is an immutable borrow to
<code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to
read <code>rect2</code> (rather than write, which would mean we’d need a mutable borrow),
and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again after
calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a
Boolean, and the implementation will check whether the width and height of
<code>self</code> are greater than the width and height of the other <code>Rectangle</code>,
respectively. Let’s add the new <code>can_hold</code> method to the <code>impl</code> block from
Listing 5-13, shown in Listing 5-15.</p>
<Listing number="5-15" file-name="src/main.rs" caption="Implementing the `can_hold` method on `Rectangle` that takes another `Rectangle` instance as a parameter">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>When we run this code with the <code>main</code> function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the <code>self</code> parameter, and those parameters work just like
parameters in functions.</p>
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h3>
<p>All functions defined within an <code>impl</code> block are called <em>associated functions</em>
because they’re associated with the type named after the <code>impl</code>. We can define
associated functions as functions that don’t have <code>self</code> as their first parameter (and thus
are not methods) because they don’t need an instance of the type to work with.
We’ve already used one function like this: the <code>String::from</code> function that’s
defined on the <code>String</code> type.</p>
<p>Associated functions that aren’t methods are often used for constructors that
will return a new instance of the struct. These are often called <code>new</code>, but
<code>new</code> isn’t a special name and isn’t built into the language. For example, we
could choose to provide an associated function named <code>square</code> that would have
one dimension parameter and use that as both width and height, thus making it
easier to create a square <code>Rectangle</code> rather than having to specify the same
value twice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>The <code>Self</code> keywords in the return type and in the body of the function are
aliases for the type that appears after the <code>impl</code> keyword, which in this case
is <code>Rectangle</code>.</p>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name;
<code>let sq = Rectangle::square(3);</code> is an example. This function is namespaced by
the struct: the <code>::</code> syntax is used for both associated functions and
namespaces created by modules. We’ll discuss modules in <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">Chapter
7</a><!-- ignore -->.</p>
<h3 id="multiple-impl-blocks"><a class="header" href="#multiple-impl-blocks">Multiple <code>impl</code> Blocks</a></h3>
<p>Each struct is allowed to have multiple <code>impl</code> blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method in
its own <code>impl</code> block.</p>
<Listing number="5-16" caption="Rewriting Listing 5-15 using multiple `impl` blocks">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>There’s no reason to separate these methods into multiple <code>impl</code> blocks here,
but this is valid syntax. We’ll see a case in which multiple <code>impl</code> blocks are
useful in Chapter 10, where we discuss generic types and traits.</p>
<h3 id="method-calls-are-syntactic-sugar-for-function-calls"><a class="header" href="#method-calls-are-syntactic-sugar-for-function-calls">Method Calls are Syntactic Sugar for Function Calls</a></h3>
<p>Using the concepts we've discussed so far, we can now see how method calls are syntactic sugar for function calls. For example, let's say we have a rectangle struct with an <code>area</code> method and a <code>set_width</code> method:</p>
<pre><code class="language-rust ignore"><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn set_width(&amp;mut self, width: u32) {
        self.width = width;
    }
}</code></pre>
<p>And let's say we have a rectangle <code>r</code>. Then the method calls <code>r.area()</code> and <code>r.set_width(2)</code> are equivalent to this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn area(&amp;self) -&gt; u32 {
</span><span class="boring">       self.width * self.height
</span><span class="boring">     }
</span><span class="boring">
</span><span class="boring">    fn set_width(&amp;mut self, width: u32) {
</span><span class="boring">        self.width = width;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut r = Rectangle { 
        width: 1,
        height: 2
    };
    let area1 = r.area();
    let area2 = Rectangle::area(&amp;r);
    assert_eq!(area1, area2);

    r.set_width(2);
    Rectangle::set_width(&amp;mut r, 2);
<span class="boring">}</span></code></pre></pre>
<p>The method call <code>r.area()</code> becomes <code>Rectangle::area(&amp;r)</code>. The function name is the associated function <code>Rectangle::area</code>. The function argument is the <code>&amp;self</code> parameter. Rust automatically inserts the borrowing operator <code>&amp;</code>.</p>
<blockquote>
<p><em>Note:</em> if you are familiar with C or C++, you are used to two different syntaxes for method calls: <code>r.area()</code> and <code>r-&gt;area()</code>. Rust does not have an equivalent to the arrow operator <code>-&gt;</code>. Rust will automatically reference and dereference the method receiver when you use the dot operator.</p>
</blockquote>
<p>The method call <code>r.set_width(2)</code> similarly becomes <code>Rectangle::set_width(&amp;mut r, 2)</code>. This method expects <code>&amp;mut self</code>, so the first argument is a mutable borrow <code>&amp;mut r</code>. The second argument is exactly the same, the number 2.</p>
<p>As we described in Chapter 4.2 <a href="ch04-02-references-and-borrowing.html#dereferencing-a-pointer-accesses-its-data">"Dereferencing a Pointer Accesses Its Data"</a>, Rust will insert as many references and dereferences as needed to make the types match up for the <code>self</code> parameter. For example, here are two equivalent calls to <code>area</code> for a mutable reference to a boxed rectangle:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn area(&amp;self) -&gt; u32 {
</span><span class="boring">       self.width * self.height
</span><span class="boring">     }
</span><span class="boring">
</span><span class="boring">    fn set_width(&amp;mut self, width: u32) {
</span><span class="boring">        self.width = width;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">fn main() {
</span>    let r = &amp;mut Box::new(Rectangle { 
        width: 1,
        height: 2
    });
    let area1 = r.area();
    let area2 = Rectangle::area(&amp;**r);
    assert_eq!(area1, area2);
<span class="boring">}</span></code></pre></pre>
<p>Rust will add two dereferences (once for the mutable reference, once for the box) and then one immutable borrow because <code>area</code> expects <code>&amp;Rectangle</code>. Note that this is also a situation where a mutable reference is "downgraded" into a shared reference, like we discussed in <a href="ch04-02-references-and-borrowing.html#mutable-references-provide-unique-and-non-owning-access-to-data">Chapter 4.2</a>. Conversely, you would not be allowed to call <code>set_width</code> on a value of type <code>&amp;Rectangle</code> or <code>&amp;Box&lt;Rectangle&gt;</code>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch05-03-method-syntax-sec1&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Rust does not have a keyword for constructor functions. The idiomatic way to define a constructor function is to make an associated function called `new`, \nbut that is not enforced by the language.\n&quot;,&quot;id&quot;:&quot;ae4e06f6-5fdc-43d9-929c-85eba3559a82&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;None of the above&quot;},&quot;prompt&quot;:{&quot;answerIndex&quot;:3,&quot;distractors&quot;:[&quot;`constructor`&quot;,&quot;`new`&quot;,&quot;The name of the type being constructed&quot;],&quot;prompt&quot;:&quot;What is the keyword for constructor functions in Rust?&quot;}},{&quot;context&quot;:&quot; \nMethods can only be implemented for types (e.g. `impl Point`), not variables (like `p`).\n&quot;,&quot;id&quot;:&quot;a506f97d-2b51-4517-bc4d-f69764093c71&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:5},&quot;prompt&quot;:{&quot;program&quot;:&quot;struct Point(i32, i32);\nfn main() {\n  let p = Point(1, 2);\n\n  impl p {\n    fn x(&amp;self) -&gt; i32 { self.0 }\n  }\n  \n  println!(\&quot;{}\&quot;, p.x());\n}\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h3 id="methods-and-ownership"><a class="header" href="#methods-and-ownership">Methods and Ownership</a></h3>
<p>Like we discussed in Chapter 4.2 <a href="ch04-02-references-and-borrowing.html">"References and Borrowing"</a>, methods must be called on structs that have the necessary permissions. As a running example, we will use these three methods that take <code>&amp;self</code>, <code>&amp;mut self</code>, and <code>self</code>, respectively.</p>
<pre><code class="language-rust ignore">impl Rectangle {    
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn set_width(&amp;mut self, width: u32) {
        self.width = width;
    }

    fn max(self, other: Rectangle) -&gt; Rectangle {
        Rectangle { 
            width: self.width.max(other.width),
            height: self.height.max(other.height),
        }
    }
}</code></pre>
<h4 id="reads-and-writes-with-self-and-mut-self"><a class="header" href="#reads-and-writes-with-self-and-mut-self">Reads and Writes with <code>&amp;self</code> and <code>&amp;mut self</code></a></h4>
<p>If we make an owned rectangle with <code>let rect = Rectangle { ... }</code>, then <code>rect</code> has @Perm{read} and @Perm{own} permissions. With those permissions, it is permissible to call the <code>area</code> and <code>max</code> methods:</p>
<pre><code class="language-aquascope permissions boundaries stepper">#struct Rectangle {
#    width: u32,
#    height: u32,
#}
#impl Rectangle {    
#  fn area(&amp;self) -&gt; u32 {
#    self.width * self.height
#  }
#
#  fn set_width(&amp;mut self, width: u32) {
#    self.width = width;
#  }
#
#  fn max(self, other: Self) -&gt; Self {
#    let w = self.width.max(other.width);
#    let h = self.height.max(other.height);
#    Rectangle { 
#      width: w,
#      height: h
#    }
#  }
#}
#fn main() {
let rect = Rectangle {
    width: 0,
    height: 0
};`(focus,rxpaths:^rect$)`
println!("{}", rect.area());`{}`

let other_rect = Rectangle { width: 1, height: 1 };
let max_rect = rect.max(other_rect);`{}`
#}
</code></pre>
<p>However, if we try to call <code>set_width</code>, we are missing the @Perm{write} permission:</p>
<pre><code class="language-aquascope permissions boundaries shouldFail">#struct Rectangle {
#    width: u32,
#    height: u32,
#}
#impl Rectangle {    
#  fn area(&amp;self) -&gt; u32 {
#    self.width * self.height
#  }
#
#  fn set_width(&amp;mut self, width: u32) {
#    self.width = width;
#  }
#
#  fn max(self, other: Self) -&gt; Self {
#    let w = self.width.max(other.width);
#    let h = self.height.max(other.height);
#    Rectangle { 
#      width: w,
#      height: h
#    }
#  }
#}
#fn main() {
let rect = Rectangle {
    width: 0,
    height: 0
};
rect.set_width(0);`{}`
#}
</code></pre>
<p>Rust will reject this program with the corresponding error:</p>
<pre><code class="language-text">error[E0596]: cannot borrow `rect` as mutable, as it is not declared as mutable
  --&gt; test.rs:28:1
   |
24 | let rect = Rectangle {
   |     ---- help: consider changing this to be mutable: `mut rect`
...
28 | rect.set_width(0);
   | ^^^^^^^^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<p>We will get a similar error if we try to call <code>set_width</code> on an immutable reference to a <code>Rectangle</code>, even if the underlying rectangle is mutable:</p>
<pre><code class="language-aquascope permissions boundaries stepper shouldFail">#struct Rectangle {
#    width: u32,
#    height: u32,
#}
#impl Rectangle {    
#  fn area(&amp;self) -&gt; u32 {
#    self.width * self.height
#  }
#
#  fn set_width(&amp;mut self, width: u32) {
#    self.width = width;
#  }
#
#  fn max(self, other: Self) -&gt; Self {
#    let w = self.width.max(other.width);
#    let h = self.height.max(other.height);
#    Rectangle { 
#      width: w,
#      height: h
#    }
#  }
#}
#fn main() {
// Added the mut keyword to the let-binding
let mut rect = Rectangle {
    width: 0,
    height: 0
};`(focus,rxpaths:^rect$)`
rect.set_width(1);`{}`     // this is now ok

let rect_ref = &amp;rect;`(focus,rxpaths:^\*rect_ref$)`
rect_ref.set_width(2);`{}` // but this is still not ok
#}
</code></pre>
<h4 id="moves-with-self"><a class="header" href="#moves-with-self">Moves with <code>self</code></a></h4>
<p>Calling a method that expects <code>self</code> will move the input struct (unless the struct implements <code>Copy</code>). For example, we cannot use a <code>Rectangle</code> after passing it to <code>max</code>:</p>
<pre><code class="language-aquascope permissions boundaries stepper shouldFail">#struct Rectangle {
#    width: u32,
#    height: u32,
#}
#impl Rectangle {    
#  fn area(&amp;self) -&gt; u32 {
#    self.width * self.height
#  }
#
#  fn set_width(&amp;mut self, width: u32) {
#    self.width = width;
#  }
#
#  fn max(self, other: Self) -&gt; Self {
#    let w = self.width.max(other.width);
#    let h = self.height.max(other.height);
#    Rectangle { 
#      width: w,
#      height: h
#    }
#  }
#}
#fn main() {
let rect = Rectangle {
    width: 0,
    height: 0
};`(focus,rxpaths:^rect$)`
let other_rect = Rectangle { 
    width: 1, 
    height: 1 
};
let max_rect = rect.max(other_rect);`(focus,rxpaths:^rect$)`
println!("{}", rect.area());`{}`
#}
</code></pre>
<p>Once we call <code>rect.max(..)</code>, we move <code>rect</code> and so lose all permissions on it. Trying to compile this program would give us the following error:</p>
<pre><code class="language-text">error[E0382]: borrow of moved value: `rect`
  --&gt; test.rs:33:16
   |
24 | let rect = Rectangle {
   |     ---- move occurs because `rect` has type `Rectangle`, which does not implement the `Copy` trait
...
32 | let max_rect = rect.max(other_rect);
   |                     --------------- `rect` moved due to this method call
33 | println!("{}", rect.area());
   |                ^^^^^^^^^^^ value borrowed here after move
</code></pre>
<p>A similar situation arises if we try to call a <code>self</code> method on a reference. For instance, say we tried to make a method <code>set_to_max</code> that assigns <code>self</code> to the output of <code>self.max(..)</code>:</p>
<pre><code class="language-aquascope permissions boundaries stepper shouldFail">#struct Rectangle {
#    width: u32,
#    height: u32,
#}
impl Rectangle {    
#  fn area(&amp;self) -&gt; u32 {
#    self.width * self.height
#  }
#
#  fn set_width(&amp;mut self, width: u32) {
#    self.width = width;
#  }
#
#  fn max(self, other: Self) -&gt; Self {
#    let w = self.width.max(other.width);
#    let h = self.height.max(other.height);
#    Rectangle { 
#      width: w,
#      height: h
#    }
#  }
    fn set_to_max(&amp;mut self, other: Rectangle) {`(focus,rxpaths:^\*self$)`
        *self = self.max(other);`{}`
    }
}
</code></pre>
<p>Then we can see that <code>self</code> is missing @Perm{own} permissions in the operation <code>self.max(..)</code>. Rust therefore rejects this program with the following error:</p>
<pre><code class="language-text">error[E0507]: cannot move out of `*self` which is behind a mutable reference
  --&gt; test.rs:23:17
   |
23 |         *self = self.max(other);
   |                 ^^^^^----------
   |                 |    |
   |                 |    `*self` moved due to this method call
   |                 move occurs because `*self` has type `Rectangle`, which does not implement the `Copy` trait
   |
</code></pre>
<p>This is the same kind of error we discussed in Chapter 4.3 <a href="ch04-03-fixing-ownership-errors.html#fixing-an-unsafe-program-copying-vs-moving-out-of-a-collection">"Copying vs. Moving Out of a Collection"</a>.</p>
<h4 id="good-moves-and-bad-moves"><a class="header" href="#good-moves-and-bad-moves">Good Moves and Bad Moves</a></h4>
<p>You might wonder: why does it matter if we move out of <code>*self</code>? In fact, for the case of <code>Rectangle</code>, it actually is safe to move out of <code>*self</code>, even though Rust doesn't let you do it. For example, if we simulate a program that calls the rejected <code>set_to_max</code>, you can see how nothing unsafe occurs:</p>
<pre><code class="language-aquascope interpreter shouldFail horizontal">#struct Rectangle {
#    width: u32,
#    height: u32,
#}
impl Rectangle {    
#  fn max(self, other: Self) -&gt; Self {
#    let w = self.width.max(other.width);
#    let h = self.height.max(other.height);
#    Rectangle { 
#      width: w,
#      height: h
#    }
#  }
    fn set_to_max(&amp;mut self, other: Rectangle) {
        let max = self.max(other);`[]`
        *self = max;
    }
}

fn main() {
    let mut rect = Rectangle { width: 0, height: 1 };
    let other_rect = Rectangle { width: 1, height: 0 };`[]`
    rect.set_to_max(other_rect);`[]`
}
</code></pre>
<p>The reason it's safe to move out of <code>*self</code> is because <code>Rectangle</code> does not own any heap data.
In fact, we can actually get Rust to compile <code>set_to_max</code> by simply adding <code>#[derive(Copy, Clone)]</code> to the definition of <code>Rectangle</code>:</p>
<pre><code class="language-aquascope permissions boundaries stepper">\#[derive(Copy, Clone)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {    
#  fn max(self, other: Self) -&gt; Self {
#    let w = self.width.max(other.width);
#    let h = self.height.max(other.height);
#    Rectangle { 
#      width: w,
#      height: h
#    }
#  }
    fn set_to_max(&amp;mut self, other: Rectangle) {`(focus,rxpaths:^\*self$)`
        *self = self.max(other);`{}`
    }
}
</code></pre>
<p>Notice that unlike before, <code>self.max(other)</code> no longer requires the @Perm{own} permission on <code>*self</code> or <code>other</code>. Remember that <code>self.max(other)</code> desugars to <code>Rectangle::max(*self, other)</code>. The dereference <code>*self</code> does not require ownership over <code>*self</code> if <code>Rectangle</code> is copyable.</p>
<p>You might wonder: why doesn't Rust automatically derive <code>Copy</code> for <code>Rectangle</code>? Rust does not auto-derive <code>Copy</code> for stability across API changes. Imagine that the author of the <code>Rectangle</code> type decided to add a <code>name: String</code> field. Then all client code that relies on <code>Rectangle</code> being <code>Copy</code> would suddenly get rejected by the compiler. To avoid that issue, API authors must explicitly add <code>#[derive(Copy)]</code> to indicate that they expect their struct to always be <code>Copy</code>.</p>
<p>To better understand the issue, let's run a simulation. Say we added <code>name: String</code> to <code>Rectangle</code>. What would happen if Rust allowed <code>set_to_max</code> to compile?</p>
<pre><code class="language-aquascope interpreter shouldFail horizontal">struct Rectangle {
    width: u32,
    height: u32,
    name: String,
}

impl Rectangle {    
#  fn max(self, other: Self) -&gt; Self {
#    let w = self.width.max(other.width);
#    let h = self.height.max(other.height);
#    Rectangle { 
#      width: w,
#      height: h,
#      name: String::from("max")
#    }
#  }
    fn set_to_max(&amp;mut self, other: Rectangle) {
        `[]`let max = self.max(other);`[]`
        drop(*self);`[]` // This is usually implicit,
                         // but added here for clarity.
        *self = max;
    }
}

fn main() {
    let mut r1 = Rectangle { 
        width: 9, 
        height: 9, 
        name: String::from("r1") 
    };
    let r2 = Rectangle {
        width: 16,
        height: 16,
        name: String::from("r2")
    };
    r1.set_to_max(r2);
}
</code></pre>
<p>In this program, we call <code>set_to_max</code> with two rectangles <code>r1</code> and <code>r2</code>. <code>self</code> is a mutable reference to <code>r1</code> and <code>other</code> is a move of <code>r2</code>. After calling <code>self.max(other)</code>, the <code>max</code> method consumes ownership of both rectangles. When <code>max</code> returns, Rust deallocates both strings "r1" and "r2" in the heap. Notice the problem: at the location L2, <code>*self</code> is supposed to be readable and writable. However, <code>(*self).name</code> (actually <code>r1.name</code>) has been deallocated.</p>
<p>Therefore when we do <code>*self = max</code>, we encounter undefined behavior. When we overwrite <code>*self</code>, Rust will implicitly drop the data previously in <code>*self</code>. To make that behavior explicit, we have added <code>drop(*self)</code>. After calling <code>drop(*self)</code>, Rust attempts to free <code>(*self).name</code> a second time. That action is a double-free, which is undefined behavior.</p>
<p>So remember: when you see an error like "cannot move out of <code>*self</code>", that's usually because you're trying to call a <code>self</code> method on a reference like <code>&amp;self</code> or <code>&amp;mut self</code>. Rust is protecting you from a double-free.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. In <code>impl</code> blocks, you can define
functions that are associated with your type, and methods are a kind of
associated function that let you specify the behavior that instances of your
structs have.</p>
<p>But structs aren’t the only way you can create custom types: let’s turn to
Rust’s enum feature to add another tool to your toolbox.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch05-03-method-syntax-sec2&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The expression `v.len()` desugars to `Vec::len(&amp;*v)`, which is a valid re-borrow of `v`, so this expression compiles.\nYou cannot, however, pass `v` directly to `Vec::len`, since `&amp;self` specifically refers to immutable references.\n&quot;,&quot;id&quot;:&quot;97781ca8-ad58-449c-9769-e20b9d2e42a6&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It compiles, because the `&amp;mut` reference is implicitly reborrowed as an `&amp;` reference&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does not compile, because `&amp;mut Vec&lt;i32&gt;` is not the same type as `&amp;Vec&lt;i32&gt;`&quot;,&quot;It does not compile, `v` is not explicitly dereferenced&quot;,&quot;It compiles, because `&amp;self` can take any kind of reference&quot;],&quot;prompt&quot;:&quot;Say you have a variable `v` of type `&amp;mut Vec&lt;i32&gt;`, and you want to call the `len` method with the\nfollowing signature:\n\n```\nimpl Vec&lt;i32&gt; {\n  fn len(&amp;self) -&gt; usize {\n    /* ... */\n  }\n}\n```\n\nIf you try to compile the expression `v.len()`, which of the following statements best describes what happens?\n&quot;}},{&quot;context&quot;:&quot;The `incr_v1` method is not idiomatic, because it consumes ownership of the `Point`. This means after calling `p.incr_v1()`, `p` \nwould be unusable, which is probably not intended for this method.\n&quot;,&quot;id&quot;:&quot;35a75881-eb08-486c-92b3-413ab512138a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`incr_v2`&quot;},&quot;prompt&quot;:{&quot;answerIndex&quot;:1,&quot;distractors&quot;:[&quot;`incr_v1`&quot;,&quot;Both are idiomatic&quot;,&quot;Neither are idiomatic&quot;],&quot;prompt&quot;:&quot;Consider these two methods that increment a field of a struct. Which style would be more idiomatic for Rust?\n\n```\nstruct Point(i32, i32);\nimpl Point {\n  fn incr_v1(mut self)  { self.0 += 1; }\n  fn incr_v2(&amp;mut self) { self.0 += 1; }\n}\n```\n&quot;}},{&quot;context&quot;:&quot; \nRemember that `.0` is valid for tuple structs like `Point`.\n&quot;,&quot;id&quot;:&quot;03a0a1ec-8ce6-40f2-b8b7-6dd5402aeb7d&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;1&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;struct Point(i32, i32);\nimpl Point {\n  fn incr_x(&amp;mut self) {\n    self.0 += 1;\n  }\n}\n\nfn main() {\n  let mut p = Point(0, 0);\n  p.incr_x();\n  println!(\&quot;{}\&quot;, p.0);\n}\n&quot;}},{&quot;context&quot;:&quot; \nBecause `get_x` mutably borrows all of `p`, a program cannot use `p` in any way until `x` is no longer used. \nTherefore reading `x` and `p.y` in the same line is an ownership error.\n&quot;,&quot;id&quot;:&quot;be7be598-8a31-4c1a-9171-4ff90f512430&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:16},&quot;prompt&quot;:{&quot;program&quot;:&quot;struct Point {\n  x: i32,\n  y: i32\n}\n\nimpl Point {\n  fn get_x(&amp;mut self) -&gt; &amp;mut i32 {\n    &amp;mut self.x\n  }\n}\n\nfn main() {\n  let mut p = Point { x: 1, y: 2 };\n  let x = p.get_x();\n  *x += 1;\n  println!(\&quot;{} {}\&quot;, *x, p.y);\n}\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css">
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-02-example-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-00-enums.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-02-example-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-00-enums.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="js-extensions/packages/telemetry/dist/index.js"></script>
        <script src="js-extensions/packages/feedback/dist/index.js"></script>



    </div>
    </body>
</html>
