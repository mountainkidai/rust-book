<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Design Trade-offs - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="js-extensions/packages/feedback/dist/index.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/rust-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="design-trade-offs"><a class="header" href="#design-trade-offs">Design Trade-offs</a></h1>
<p>This section is about <strong>design trade-offs</strong> in Rust. To be an effective Rust engineer, it's not enough just to know how Rust works. You have to decide which of Rust's many tools are appropriate for a given job. In this section, we will give you a sequence of quizzes about your understanding of design trade-offs in Rust.  After each quiz, we will explain in-depth our rationale for each question.</p>
<p>Here's an example of what a question will look like. It will start out by describing a software case study with a space of designs:</p>
<blockquote>
<p><strong>Context:</strong> You are designing an application with a global configuration, e.g. containing command-line flags.</p>
<p><strong>Functionality:</strong> The application needs to pass immutable references to this configuration throughout the application.</p>
<p><strong>Designs:</strong> Below are several proposed designs to implement the functionality.</p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::sync::Arc;

struct Config { 
    flags: Flags,
    // .. more fields ..
}

// Option 1: use a reference
struct ConfigRef&lt;'a&gt;(&amp;'a Config);

// Option 2: use a reference-counted pointer
struct ConfigRef(Rc&lt;Config&gt;);

// Option 3: use an atomic reference-counted pointer
struct ConfigRef(Arc&lt;Config&gt;);</code></pre>
</blockquote>
<p>Given just the context and key functionality, all three designs are potential candidates.
We need more information about the system goals to decide which ones make the most sense.
Hence, we give a new requirement:</p>
<blockquote>
<p>Select each design option that satisfies the following requirement:</p>
<p><strong>Requirement:</strong> The configuration reference must be shareable between multiple threads.</p>
<p><strong>Answer:</strong></p>
<p><input type="checkbox" checked disabled> Option 1 <br>
<input type="checkbox" disabled> Option 2 <br>
<input type="checkbox" checked disabled> Option 3 <br></p>
</blockquote>
<p>In formal terms, this means that <code>ConfigRef</code> implements <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>.
Assuming <code>Config: Send + Sync</code>, then both <code>&amp;Config</code> and <code>Arc&lt;Config&gt;</code> satisfy this requirement,
but <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> does not (because non-atomic reference-counted pointers are not thread-safe). So Option 2 does not satisfy the requirement, while Option 3 does.</p>
<p>We might also be tempted to conclude that Option 1 does not satisfy the requirement because functions like <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a> require that all data moved into a thread can only contain references with a <code>'static</code> lifetime. However, that does not rule out Option 1 for two reasons:</p>
<ol>
<li>The <code>Config</code> could be stored as a global static variable (e.g., using <a href="https://doc.rust-lang.org/std/sync/struct.OnceLock.html"><code>OnceLock</code></a>), so one could construct <code>&amp;'static Config</code> references.</li>
<li>Not all concurrency mechanisms require <code>'static</code> lifetimes, such as <a href="https://doc.rust-lang.org/std/thread/fn.scope.html"><code>thread::scope</code></a>.</li>
</ol>
<p>Therefore the requirement as-stated only rules out non-<a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> types, and we consider Options 1 and 3 to be the correct answers.</p>
<hr>
<p>Now you try with the questions below! Each section contains a quiz focused on a single scenario. Complete the quiz, and make sure to read the answer context after each quiz.</p>
 <!-- These questions are both experimental and opinionated &mdash; please leave us feedback via the bug button 🐞 if you disagree with our answers. -->
<p>Along with each quiz, we have also provided links to popular Rust crates that served as inspiration for the quiz.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p><em>Inspiration:</em> <a href="https://docs.rs/bevy/0.11.2/bevy/asset/struct.Assets.html">Bevy assets</a>, <a href="https://docs.rs/petgraph/0.6.4/petgraph/graph/struct.NodeIndex.html">Petgraph node indices</a>, <a href="https://docs.rs/cargo/0.73.1/cargo/core/compiler/struct.Unit.html">Cargo units</a></p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch17-05-design-challenge-references&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The immutability of assets is enforced by types that don't permit mutating operations. Both an immutable borrow `&amp;Asset`\nand an immutable smart-pointer like `Rc` don't permit mutating operations. Therefore Options 1, 3, and 4 DO satisfy this requirement.\nOption 2 returns a mutable borrow, which does NOT satisfy the requirement.\n&quot;,&quot;id&quot;:&quot;10ae140e-72a6-4594-802a-d656f33cd836&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;1&quot;,&quot;3&quot;,&quot;4&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;2&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** Once loaded, an asset should be permanently immutable.\n&quot;,&quot;sortAnswers&quot;:true}},{&quot;context&quot;:&quot;\&quot;Retaining access across borrows\&quot; means the client wants to write a program like this:\n\n```\nlet asset = {\n    let manager = get_manager();\n    manager.load(\&quot;some/path\&quot;)\n};\nprocess_asset(asset);\nlet another_asset = {\n    let manager = get_manager();\n    manager.load(\&quot;another/path\&quot;)\n};\n```\n\nIn this case, the lifetime of the value returned by `load` must not be tied to the lifetime of the `AssetManager`. Options 1 and 2\nrequire that the `&amp;Asset` and `&amp;mut Asset` only live as long as the `&amp;mut self`. Therefore the borrow checker\nwould reject programs like the one above where an asset outlives the manager reference. Options 1 and 2 do NOT satisfy the requirement.\n\nOptions 3 and 4 DO satisfy the requirement. The lifetime of `Rc&lt;Asset&gt;` is not tied to the lifetime of `&amp;mut self`. Similarly, the lifetime\nof `AssetHandle` is not tied to the lifetime of `&amp;mut self`.\n&quot;,&quot;id&quot;:&quot;b69cde98-8ccd-4a89-aeeb-80a3338f9e68&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;3&quot;,&quot;4&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;1&quot;,&quot;2&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:**  Clients of the asset manager need to retain access to assets across several short-term borrows of the asset manager.\n&quot;,&quot;sortAnswers&quot;:true}},{&quot;context&quot;:&quot;To deallocate all assets at a single time, the `AssetManager` must retain exclusive ownership over them.\nTherefore when the `AssetManager` is dropped (or otherwise instructed to deallocate assets), \nit is guaranteed that all of the assets can be safely dropped.\nOptions 1, 2, and 4 DO satisfy this requirement. Option 4 would require that `AssetManager::get` panics if\nthe client calls `manager.get(handle)` after an asset has been deallocated. If there is a real chance a client may do this,\nanother alternative would be for `get` to return `Option&lt;&amp;Asset&gt;`.\n\nOption 3 does NOT satisfy this requirement. Reference-counted pointers are jointly owned by every owner of an `Rc&lt;Asset&gt;`.\nThe `AssetManager` has no good way to ensure that all assets have no other owners at deallocation time.\n&quot;,&quot;id&quot;:&quot;48527488-ecfc-4f16-9824-76a3ac7183f4&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;1&quot;,&quot;2&quot;,&quot;4&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;3&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** It is important that all assets be deallocated at a single, predictable time.\n&quot;,&quot;sortAnswers&quot;:true}}],&quot;multipart&quot;:{&quot;q&quot;:&quot;**Context:** You are designing a simple asset manager for a game engine.\n\n**Functionality:** An API client will provide paths of assets to load, and gets back access to the loaded assets.\n\n**Assumptions:** You may assume that loads happen synchronously and instantaneously.\n\n**Designs:** Below are several proposed designs to implement the functionality.\n\n```\npub struct AssetManager {\n    // ...\n}\n\n// Option 1: return a reference\nimpl AssetManager {\n    pub fn load(&amp;mut self, path: PathBuf) -&gt; &amp;Asset;\n}\n\n// Option 2: return a mutable reference\nimpl AssetManager {\n    pub fn load(&amp;mut self, path: PathBuf) -&gt; &amp;mut Asset;\n}\n\n// Option 3: return a reference-counted pointer\nimpl AssetManager {\n    pub fn load(&amp;mut self, path: PathBuf) -&gt; Rc&lt;Asset&gt;;\n}\n\n// Option 4: return a copyable handle that can be turned into a reference\n#[derive(Copy, Clone)]\npub struct AssetHandle(usize);\n\nimpl AssetManager {\n    pub fn load(&amp;mut self, path: PathBuf) -&gt; AssetHandle;\n    pub fn get(&amp;self, handle: AssetHandle) -&gt; &amp;Asset;\n}\n```\n&quot;}}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h2 id="trait-trees"><a class="header" href="#trait-trees">Trait Trees</a></h2>
<p><em>Inspiration:</em> <a href="https://docs.rs/yew/0.20.0/yew/html/trait.Component.html">Yew components</a>, <a href="https://docs.rs/druid/0.8.3/druid/trait.Widget.html">Druid widgets</a></p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch17-05-design-challenge-trait-trees&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;If we represent all possible widgets as a single enum, like this:\n\n```\nenum WidgetImpl {\n  Button { /* .. */ },\n  Text { /* .. */ },\n  // ..\n}\n\nimpl Widget for WidgetImpl { /* .. */ }\n```\n\nThen we have a \&quot;closed world\&quot; system where there is a non-extensible set of possible widgets. There is only one implementation of `Widget`, and no need for dynamic dispatch. \nTherefore only Option 1 makes sense, because `render` would only ever return other `WidgetImpl` types. All other designs contain unnecessary complexity under this requirement.\n&quot;,&quot;id&quot;:&quot;e529cabf-a14c-4f1b-865f-1f376b704df8&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;1&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** The API client is expected to provide a single `WidgetImpl` enum representing all possible widgets, and implement the `Widget` trait for `WidgetImpl`.\n&quot;,&quot;sortAnswers&quot;:true}},{&quot;context&quot;:&quot;Unlike the previous question, now we expect to have a distinct type for each widget, like:\n\n```\nstruct Button { /* .. */ }\nimpl Widget for Button { /* .. */ }\n\nstruct Text { /* .. */ }\nimpl Widget for Text { /* .. */ }\n```\n\nTherefore a vector of widgets needs to be heterogeneous, i.e., it could contain widgets of distinct types.\nOptions 1, 2, and 3 all constrain each `Widget::render` implementation to return a vector of a single widget type.\nOptions 4 and 5 use dynamic dispatch via trait objects to permit heterogeneous widget vectors.\n&quot;,&quot;id&quot;:&quot;0fdd5ca0-835f-4999-8d24-37841cb0a1a7&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;4&quot;,&quot;5&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** The API client is expected to provide a unique struct for each possible widget, and implement the `Widget` trait for each struct. \nEach widget can return a vector containing widgets of any possible type.\n&quot;,&quot;sortAnswers&quot;:true}},{&quot;context&quot;:&quot;The `Widget` trait in Option 2 does not constrain that `Children: Widget`. \nAll other options do ensure return a `Vec&lt;W&gt;` for some `W` where `W: Widget`.\n&quot;,&quot;id&quot;:&quot;fbed1c75-737c-49f5-8f11-66d25391079b&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;1&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;2&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** Only types that implement the `Widget` trait should be returned from `render`.\n&quot;,&quot;sortAnswers&quot;:true}}],&quot;multipart&quot;:{&quot;q&quot;:&quot;**Context:** You are designing a simple user interface framework that consists of a tree of widgets, such as text and buttons.\n\n**Functionality:** The API provides a `Widget` trait that defines how a widget works. The API client implements the `Widget` trait, and calls it to render a UI.\n\n**Designs:** Below are several proposed designs to implement the functionality.\n\n```\n// Option 1: children must be Self\npub trait Widget: Sized {\n\tfn render(&amp;self) -&gt; Vec&lt;Self&gt;;\n}\n\n// Option 2: children are a trait parameter\npub trait Widget&lt;Children&gt; {\n\tfn render(&amp;self) -&gt; Vec&lt;Children&gt;;\n}\n\n// Option 3: children are an associated type\npub trait Widget {\n\ttype Children: Widget;\n\tfn render(&amp;self) -&gt; Vec&lt;Self::Children&gt;;\n}\n\n// Option 4: children are a reference trait object\npub trait Widget {\n\tfn render(&amp;self) -&gt; Vec&lt;&amp;dyn Widget&gt;;\n}\n\n// Option 5: children are a boxed trait object\npub trait Widget {\n\tfn render(&amp;self) -&gt; Vec&lt;Box&lt;dyn Widget&gt;&gt;;\n}\n```\n&quot;}}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h2 id="dispatch"><a class="header" href="#dispatch">Dispatch</a></h2>
<p><em>Inspiration:</em> <a href="https://docs.rs/bevy_ecs/0.11.2/bevy_ecs/system/trait.IntoSystem.html">Bevy systems</a>, <a href="https://docs.diesel.rs/2.1.x/diesel/query_dsl/trait.BelongingToDsl.html">Diesel queries</a>, <a href="https://docs.rs/axum/0.6.20/axum/handler/trait.Handler.html">Axum handlers</a></p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch17-05-design-challenge-dispatch&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;First, let's imagine what it would look like to register a callback under each design.\n\n```rust\n// Option 1\nevents.register(|e: OnClick| { /* .. */ });\nevents.register_sequential(|e: OnClick| { /* .. */ })\n\n// Option 2\nevents.register(Callback::Parallel(|e: OnClick| { /* .. */ }));\nevents.register(Callback::Sequential(|e: OnClick| { /* .. */ }));\n\n// Option 3\nevents.register(|e: OnClick| { /* .. */ });\nevents.register(|_: Sequential, e: OnClick| { /* .. */ });\n```\n\nOf these options, Options 1 and 3 convey that parallel is the default mode as it corresponds to the simplest option.\nBeing sequential requires either using a longer method name (`_sequential`) or a marker type (`_: Sequential)`.\n\nOption 2 does not clearly mark that parallel should be default because both `Parallel` and `Sequential` must be passed in\nto `register`.\n&quot;,&quot;id&quot;:&quot;4a32bad8-fee7-45b5-80ef-775d059aab48&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;1&quot;,&quot;3&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;2&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** A callback should be considered parallelizable by default, and the API should reflect that default behavior.\n&quot;,&quot;sortAnswers&quot;:true}},{&quot;context&quot;:&quot;Options 2 and 3 only export a single `register` method. Option 1 requires exporting two distinctly-named register methods.\n&quot;,&quot;id&quot;:&quot;eaeafdad-ac3a-4d92-85eb-995991a81c2d&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;2&quot;,&quot;3&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;1&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** The API should export as few methods as possible.\n&quot;,&quot;sortAnswers&quot;:true}},{&quot;context&quot;:&quot;Options 1 and 2 do not require much type inference beyond determining the type of the function `F`.\n\nOption 3 uses an overloading trick by creating a `Register` trait parameterized over a \&quot;marker\&quot; type.\nRemember its two register calls:\n```\nevents.register(|e: OnClick| { /* .. */ })\nevents.register(|_: Sequential, e: OnClick| { /* .. */ })\n```\n\nThese look like they use the same implementation, but they actually refer to different implementations of the same method.\nThis implementation relies on the compiler to infer the type of `Marker` when resolving which implementation of `Register` that\neach `.register(..)` call corresponds to. Therefore if our goal is to *not* rely on type inference, then Option 3 is inappropriate.\n&quot;,&quot;id&quot;:&quot;e0c4f766-b82a-496a-b669-ea9e0a367af7&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;1&quot;,&quot;2&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;3&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** The API should lean on the compiler's type inference system as little as possible.\n&quot;,&quot;sortAnswers&quot;:true}}],&quot;multipart&quot;:{&quot;q&quot;:&quot;**Context:** You are designing a simple event system that calls callback functions in response to events. \n\n**Functionality:** An `Events` struct provides functions to register callbacks.\nA callback is either parallelizable (runnable across multiple threads) or sequential (must be run only on the main thread).\n\n**Designs:** Below are several proposed designs to implement the functionality.\n\n```\npub struct Events {\n\t// ...\n}\n\n// Option 1: parallel and sequential are two separate methods\nimpl Events {\n\tpub fn register&lt;E, F: Fn(E)&gt;(&amp;mut self, f: F) { /* .. */ }\n\tpub fn register_sequential&lt;E, F: Fn(E)&gt;(&amp;mut self, f: F) { /* .. */ }\n}\n\n// Option 2: parallel and sequential are two members of an enum\npub enum Callback&lt;F&gt; {\n\tParallel(F),\n\tSequential(F)\n}\nimpl Events {\n\tpub fn register&lt;E, F: Fn(E)&gt;(&amp;mut self, f: Callback&lt;F&gt;) { /* .. */ }\n}\n\n// Option 3: parallel and sequential are markers in a trait method\npub trait Register&lt;Marker, F, E&gt; {\n\tfn register(&amp;mut self, f: F);\n}\npub struct Parallel;\npub struct Sequential;\nimpl&lt;F, E&gt; Register&lt;Parallel, F, E&gt; for Events \nwhere F: Fn(E) {\n\tfn register(&amp;mut self, f: F) { /* .. */ }\n}\nimpl&lt;F, E&gt; Register&lt;Sequential, F, E&gt; for Events \nwhere F: Fn(Sequential, E) {\n\tfn register(&amp;mut self, f: F) { /* .. */ }\n}\n```\n&quot;}}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h2 id="intermediates"><a class="header" href="#intermediates">Intermediates</a></h2>
<p><em>Inspiration:</em> <a href="https://docs.rs/serde/1.0.188/serde/trait.Serialize.html">Serde</a> and <a href="https://docs.rs/miniserde/0.1.34/miniserde/trait.Serialize.html">miniserde</a></p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch17-05-design-challenge-intermediates&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Both designs are sufficiently decoupled such that each new data format is independent of any `Serialize` implementations. For Option 1,\neach data format converts a `Value` into the format's representation. `Value` acts as a module boundary.\n\nFor Option 2, there is no explicit intermediate representation of a serialized value, but rather each `Serialize` implementation is explicitly generic\nover any choice of `S` that implements `Serializer`.\n&quot;,&quot;id&quot;:&quot;66e036c9-91a0-4611-8110-967b5ed1a514&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;1&quot;,&quot;2&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** It should be possible to add a new data format without needing to modify code in existing implementations of the `Serialize` trait.\n&quot;,&quot;sortAnswers&quot;:true}},{&quot;context&quot;:&quot;Option 1 serializes data by first converting a data structure into an intermediate representation, `Value`, and then converting `Value` into the final format.\nThis intermediate data structure consumes memory which is not needed by Option 2, where data is converted directly into the final format.\n&quot;,&quot;id&quot;:&quot;eaa95520-1b72-4f7d-a600-5444b6368785&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;2&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;1&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** The process of serialization should consume as little memory as possible.\n&quot;,&quot;sortAnswers&quot;:true}},{&quot;context&quot;:&quot;With Option 1, there is only a single instantiation of `Serialize` that converts a type `T` into a `Value`. Because Option 2 is generic over serializers `S`,\nthen every time `T::serialize` is called with a new `S`, the Rust compiler will monomorphize a new instance of `T::serialize` which would increase the size of\nthe binary by comparison to Option 1.\n&quot;,&quot;id&quot;:&quot;2751731e-7d18-46a1-aaea-b5734bf51c80&quot;,&quot;multipart&quot;:&quot;q&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;1&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;2&quot;],&quot;prompt&quot;:&quot;Select each design option that satisfies the following requirement:\n\n**Requirement:** When the same data type is serialized into multiple formats, that should increase the size of the compiled binary as little as possible.\n&quot;,&quot;sortAnswers&quot;:true}}],&quot;multipart&quot;:{&quot;q&quot;:&quot;**Context:** You are designing a serialization library that converts Rust data types into formats like JSON.\n\n**Functionality:** A `Serialize` trait that can be implemented by serializable types, and a `to_json` function that converts serializable types into JSON.\n\n**Designs:** Below are several proposed designs to implement the functionality.\n\n```\n// Option 1: types serialize to a `Value` enum\npub enum Value {\n\tString(String),\n\tNumber(isize)\n}\n\npub trait Serialize {\n\tfn serialize(&amp;self) -&gt; Value;\n}\n\nfn value_to_json(value: Value) -&gt; String {\n\t/* .. */\n}\n\npub fn to_json(data: impl Serialize) -&gt; String {\n    let value = data.serialize();\n    value_to_json(value)\n}\n\n\n// Option 2: types serialize via calls to a `Serializer` interface\npub trait Serialize {\n\tfn serialize&lt;S: Serializer&gt;(&amp;self, serializer: &amp;mut S);\n}\n\npub trait Serializer {\n\tfn serialize_string(&amp;mut self, s: &amp;str);\n\tfn serialize_number(&amp;mut self, n: isize);\n}\n\nstruct JsonSerializer { buffer: String };\nimpl Serializer for JsonSerializer {\n\t/* .. */\n}\n\npub fn to_json(data: impl Serialize) -&gt; String {\n\tlet mut serializer = JsonSerializer { buffer: String::new() };\n\tdata.serialize(&amp;mut serializer);\n\tserializer.buffer\n}\n```\n&quot;}}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css">
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-04-inventory.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-04-inventory.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="js-extensions/packages/telemetry/dist/index.js"></script>
        <script src="js-extensions/packages/feedback/dist/index.js"></script>



    </div>
    </body>
</html>
