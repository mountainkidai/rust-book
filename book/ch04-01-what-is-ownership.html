<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What is Ownership? - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="js-extensions/packages/feedback/dist/index.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/rust-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="what-is-ownership"><a class="header" href="#what-is-ownership">What Is Ownership?</a></h2>
<p>Ownership is a discipline for ensuring the <strong>safety</strong> of Rust programs. To understand ownership, we first need to understand what makes a Rust program safe (or unsafe).</p>
<h3 id="safety-is-the-absence-of-undefined-behavior"><a class="header" href="#safety-is-the-absence-of-undefined-behavior">Safety is the Absence of Undefined Behavior</a></h3>
<p>Let's start with an example. This program is safe to execute:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn read(y: bool) {
    if y {
        println!("y is true!");
    }
}

fn main() {
    let x = true;
    read(x);
}</code></pre></pre>
<p>We can make this program unsafe to execute by moving the call to <code>read</code> before the definition of <code>x</code>:</p>
<pre><code class="language-rust ignore does_not_compile">fn read(y: bool) {
    if y {
        println!("y is true!");
    }
}

fn main() {
    read(x); // oh no! x isn't defined!
    let x = true;
}</code></pre>
<blockquote>
<p><em>Note</em>: in this chapter, we will use many code examples that do not compile. Make sure to look for the question mark crab if you are not sure whether a program should compile or not.</p>
</blockquote>
<p>This second program is unsafe because <code>read(x)</code> expects <code>x</code> to have a value of type <code>bool</code>, but <code>x</code> doesn't have a value yet.</p>
<p>When a program like this is executed by an interpreter, then reading <code>x</code> before it's defined would raise an exception such as Python's <a href="https://docs.python.org/3/library/exceptions.html#NameError"><code>NameError</code></a> or Javascript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError"><code>ReferenceError</code></a>. But exceptions come at a cost. Each time an interpreted program reads a variable, then the interpreter must check whether that variable is defined.</p>
<p>Rust's goal is to compile programs into efficient binaries that require as few runtime checks as possible. Therefore Rust does not check at <em>runtime</em> whether a variable is defined before being used. Instead, Rust checks at <em>compile-time</em>. If you try to compile the unsafe program, you will get this error:</p>
<pre><code class="language-text">error[E0425]: cannot find value `x` in this scope
 --&gt; src/main.rs:8:10
  |
8 |     read(x); // oh no! x isn't defined!
  |          ^ not found in this scope
</code></pre>
<p>You probably have the intuition that it's good for Rust to ensure that variables are defined before they are used. But why? To justify the rule, we have to ask: <strong>what would happen if Rust allowed a rejected program to compile?</strong></p>
<p>Let's first consider how the safe program compiles and executes. On a computer with a processor using an <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture, Rust generates the following assembly code for the <code>main</code> function in the safe program (<a href="https://rust.godbolt.org/z/xnT1fzsqv">see the full assembly code here</a>):</p>
<pre><code class="language-x86asm">main:
    ; ...
    mov     edi, 1
    call    read
    ; ...
</code></pre>
<blockquote>
<p><em>Note</em>: if you aren't familiar with assembly code, that's ok! This section contains a few examples of assembly just to show you how Rust actually works under the hood. You don't generally need to know assembly to understand Rust.</p>
</blockquote>
<p>This assembly code will:</p>
<ul>
<li>Move the number 1, representing <code>true</code>, into a "register" (a kind of assembly variable) called <code>edi</code>.</li>
<li>Call the <code>read</code> function, which expects its first argument <code>y</code> to be in the <code>edi</code> register.</li>
</ul>
<p>If the unsafe function was allowed to compile, its assembly might look like this:</p>
<pre><code class="language-x86asm">main:
    ; ...
    call    read
    mov     edi, 1    ; mov is after call
    ; ...
</code></pre>
<p>This program is unsafe because <code>read</code> will expect <code>edi</code> to be a boolean, which is either the number <code>0</code> or <code>1</code>. But <code>edi</code> could be anything: <code>2</code>, <code>100</code>, <code>0x1337BEEF</code>. When <code>read</code> wants to use its argument <code>y</code> for any purpose, it will immediately cause <em><strong>UNDEFINED BEHAVIOR!</strong></em></p>
<p>Rust doesn't specify what happens if you try to run <code>if y { .. }</code> when <code>y</code> isn't <code>true</code> or <code>false</code>. That <em>behavior</em>, or what happens after executing the instruction, is <em>undefined</em>. Something will happen, for example:</p>
<ul>
<li>The code executes without crashing, and no one notices a problem.</li>
<li>The code immediately crashes due to a <a href="https://en.wikipedia.org/wiki/Segmentation_fault">segmentation fault</a> or another kind of operating system error.</li>
<li>The code executes without crashing, until a malicious actor creates the right input to delete your production database, overwrite your backups, and steal your lunch money.</li>
</ul>
<p><strong>A foundational goal of Rust is to ensure that your programs never have undefined behavior.</strong> That is the meaning of "safety." Undefined behavior is especially dangerous for low-level programs with direct access to memory. About <a href="https://msrc.microsoft.com/blog/2019/07/a-proactive-approach-to-more-secure-code/">70% of reported security vulnerabilities</a> in low-level systems are caused by memory corruption, which is one form of undefined behavior.</p>
<p>A secondary goal of Rust is to prevent undefined behavior at <em>compile-time</em> instead of <em>run-time</em>. This goal has two motivations:</p>
<ol>
<li>Catching bugs at compile-time means avoiding those bugs in production, improving the reliability of your software.</li>
<li>Catching bugs at compile-time means fewer runtime checks for those bugs, improving the performance of your software.</li>
</ol>
<p>Rust cannot prevent all bugs. If an application exposes a public and unauthenticated <code>/delete-production-database</code> endpoint, then a malicious actor doesn't need a suspicious if-statement to delete the database. But Rust's protections are still likely to make programs safer versus using a language with fewer protections, e.g. as found by <a href="https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html">Google's Android team</a>.</p>
<h3 id="ownership-as-a-discipline-for-memory-safety"><a class="header" href="#ownership-as-a-discipline-for-memory-safety">Ownership as a Discipline for Memory Safety</a></h3>
<p>Since safety is the absence of undefined behavior, and since ownership is about safety, then we need to understand ownership in terms of the undefined behaviors it prevents. The Rust Reference maintains a large list of <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">"Behavior considered undefined"</a>. For now, we will focus on one category: operations on memory.</p>
<p>Memory is the space where data is stored during the execution of a program. There are many ways to think about memory:</p>
<ul>
<li>If you are unfamiliar with systems programming, you might think of memory at a high level like "memory is the RAM in my computer" or "memory is the thing that runs out if I load too much data".</li>
<li>If you are familiar with systems programming, you might think of memory at a low level like "memory is an array of bytes" or "memory is the pointers I get back from <code>malloc</code>".</li>
</ul>
<p>Both of these memory models are <em>valid</em>, but they are not <em>useful</em> ways to think about how Rust works. The high-level model is too abstract to explain how Rust works. You will need to understand the concept of a pointer, for instance. The low-level model is too concrete to explain how Rust works. Rust does not allow you to interpret memory as an array of bytes, for instance.</p>
<p>Rust provides a particular way to think about memory. Ownership is a discipline for safely using memory within that way of thinking. The rest of this chapter will explain the Rust model of memory.</p>
<h3 id="variables-live-in-the-stack"><a class="header" href="#variables-live-in-the-stack">Variables Live in the Stack</a></h3>
<p>Here's a program like the one you saw in Section 3.3 that defines a number <code>n</code> and calls a function <code>plus_one</code> on <code>n</code>. Beneath the program is a new kind of diagram. This diagram visualizes the contents of memory during the program's execution at the three marked points.</p>
<pre><code class="language-aquascope interpreter horizontal">fn main() {
    let n = 5;`[]`
    let y = plus_one(n);`[]`
    println!("The value of y is: {y}");
}

fn plus_one(x: i32) -&gt; i32 {
    `[]`x + 1
}
</code></pre>
<p>Variables live in <strong>frames</strong>. A frame is a mapping from variables to values within a single scope, such as a function. For example:</p>
<ul>
<li>The frame for <code>main</code> at location L1 holds <code>n = 5</code>.</li>
<li>The frame for <code>plus_one</code> at L2 holds <code>x = 5</code>.</li>
<li>The frame for <code>main</code> at location L3 holds <code>n = 5; y = 6</code>.</li>
</ul>
<p>Frames are organized into a <strong>stack</strong> of currently-called-functions. For example, at L2 the frame for <code>main</code> sits above the frame for the called function <code>plus_one</code>. After a function returns, Rust deallocates the function's frame. (Deallocation is also called <strong>freeing</strong> or <strong>dropping</strong>, and we use those terms interchangeably.) This sequence of frames is called a stack because the most recent frame added is always the next frame freed.</p>
<blockquote>
<p><em>Note:</em> this memory model does not fully describe how Rust actually works! As we saw earlier with the assembly code, the Rust compiler might put <code>n</code> or <code>x</code> into a register rather than a stack frame. But that distinction is an implementation detail. It shouldn't change your understanding of safety in Rust, so we can focus on the simpler case of frame-only variables.</p>
</blockquote>
<p>When an expression reads a variable, the variable's value is copied from its slot in the stack frame. For example, if we run this program:</p>
<pre><code class="language-aquascope interpreter horizontal">#fn main() {
let a = 5;`[]`
let mut b = a;`[]`
b += 1;`[]`
#}
</code></pre>
<p>The value of <code>a</code> is copied into <code>b</code>, and <code>a</code> is left unchanged, even after changing <code>b</code>.</p>
<h3 id="boxes-live-in-the-heap"><a class="header" href="#boxes-live-in-the-heap">Boxes Live in the Heap</a></h3>
<p>However, copying data can take up a lot of memory. For example, here's a slightly different program. This program copies an array with 1 million elements:</p>
<pre><code class="language-aquascope interpreter">#fn main() {
let a = [0; 1_000_000];`[]`
let b = a;`[]`
#}
</code></pre>
<p>Observe that copying <code>a</code> into <code>b</code> causes the <code>main</code> frame to contain 2 million elements.</p>
<p>To transfer access to data without copying it, Rust uses <strong>pointers</strong>. A pointer is a value that describes a location in memory. The value that a pointer points-to is called its <strong>pointee.</strong> One common way to make a pointer is to allocate memory in the <strong>heap</strong>.  The heap is a separate region of memory where data can live indefinitely. Heap data is not tied to a specific stack frame. Rust provides a construct called <a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box</code></a> for putting data on the heap. For example, we can wrap the million-element array in <code>Box::new</code> like this:</p>
<pre><code class="language-aquascope interpreter">#fn main() {
let a = Box::new([0; 1_000_000]);`[]`
let b = a;`[]`
#}
</code></pre>
<p>Observe that now, there is only ever a single array at a time. At L1, the value of <code>a</code> is a pointer (represented by dot with an arrow) to the array inside the heap. The statement <code>let b = a</code> copies the pointer from <code>a</code> into <code>b</code>, but the pointed-to data is not copied. Note that <code>a</code> is now grayed out because it has been <em>moved</em> — we will see what that means in a moment.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch04-01-ownership-sec1-stackheap&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Frames in the stack are associated with a specific function, and are deallocated when the function returns.\nData on the heap can live indefinitely. Note that both stack and heap data can be mutable and can be copyable. The heap is allowed to\ncontain pointers (even to the stack, as we will see later).\n&quot;,&quot;id&quot;:&quot;5d774a01-8604-4386-8d81-498496ccd96c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The stack holds data associated with a specific function, while the heap holds data that can outlive a function&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;The stack can hold pointers to data stored on the heap, while the heap only holds data without pointers&quot;,&quot;The stack holds immutable data, while the heap holds mutable data.&quot;,&quot;The stack holds copyable data, while the heap holds uncopyable data.&quot;],&quot;prompt&quot;:&quot;Which of the following best describes the difference between the stack and the heap?\n&quot;}},{&quot;context&quot;:&quot;The two boxes contain the two copies of the number 15. The assignment `let b = a` copies the heap pointer, but not the number on the heap.\n&quot;,&quot;id&quot;:&quot;4c953b2d-65bf-4dab-bbbb-14c9b15a690e&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;2&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Consider the execution of the following snippet, with the final state shown:\n\n```aquascope,interpreter\n#fn main() {\nlet a = Box::new(15);\nlet b = a;\nlet c = Box::new(15);`[]`\n#}\n```\n\nIn the final state, how many copies of the number `15` live anywhere in memory? Write your answer as a digit, such as 0 or 1.\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h3 id="rust-does-not-permit-manual-memory-management"><a class="header" href="#rust-does-not-permit-manual-memory-management">Rust Does Not Permit Manual Memory Management</a></h3>
<p>Memory management is the process of allocating memory and deallocating memory. In other words, it's the process of finding unused memory and later returning that memory when it is no longer used. Stack frames are automatically managed by Rust. When a function is called, Rust allocates a stack frame for the called function. When the call ends, Rust deallocates the stack frame.</p>
<p>As we saw above, heap data is allocated when calling <code>Box::new(..)</code>. But when is heap data deallocated? Imagine that Rust had a <code>free()</code> function that frees a heap allocation. Imagine that Rust let a programmer call <code>free</code> whenever they wanted. This kind of "manual" memory management easily leads to bugs. For example, we could read a pointer to freed memory:</p>
<pre><code class="language-aquascope interpreter shouldFail">#fn free&lt;T&gt;(_t: T) {}
#fn main() {
let b = Box::new([0; 100]);`[]`
free(b);`[]`
assert!(b[0] == 0);`[]`
#}
</code></pre>
<blockquote>
<p><em>Note:</em> you may wonder how we are executing this Rust program that doesn't compile. We use <a href="https://github.com/cognitive-engineering-lab/aquascope">special tools</a> to simulate Rust as if the borrow checker were disabled, for educational purposes. That way we can answer what-if questions, like: what if Rust let this unsafe program compile?</p>
</blockquote>
<p>Here, we allocate an array on the heap. Then we call <code>free(b)</code>, which deallocates the heap memory of <code>b</code>. Therefore the value of <code>b</code> is a pointer to invalid memory, which we represent as the "⦻" icon. No undefined behavior has happened yet! The program is still safe at L2. It's not necessarily a problem to have an invalid pointer.</p>
<p>The undefined behavior happens when we try to <em>use</em> the pointer by reading <code>b[0]</code>. That would attempt to access invalid memory, which could cause the program to crash. Or worse, it could not crash and return arbitrary data. Therefore this program is <strong>unsafe</strong>.</p>
<p>Rust does not allow programs to manually deallocate memory. That policy avoids the kinds of undefined behaviors shown above.</p>
<h3 id="a-boxs-owner-manages-deallocation"><a class="header" href="#a-boxs-owner-manages-deallocation">A Box's Owner Manages Deallocation</a></h3>
<p>Instead, Rust <em>automatically</em> frees a box's heap memory. Here is an <em>almost</em> correct description of Rust's policy for freeing boxes:</p>
<blockquote>
<p><strong>Box deallocation principle (almost correct):</strong> If a variable is bound to a box, when Rust deallocates the variable's frame, then Rust deallocates the box's heap memory.</p>
</blockquote>
<p>For example, let's trace through a program that allocates and frees a box:</p>
<pre><code class="language-aquascope interpreter horizontal">fn main() {
    let a_num = 4;`[]`
    make_and_drop();`[]`
}

fn make_and_drop() {
    let a_box = Box::new(5);`[]`
}
</code></pre>
<p>At L1, before calling <code>make_and_drop</code>, the state of memory is just the stack frame for <code>main</code>. Then at L2, while calling <code>make_and_drop</code>, <code>a_box</code> points to <code>5</code> on the heap. Once <code>make_and_drop</code> is finished, Rust deallocates its stack frame. <code>make_and_drop</code> contains the variable <code>a_box</code>, so Rust also deallocates the heap data in <code>a_box</code>. Therefore the heap is empty at L3.</p>
<p>The box's heap memory has been successfully managed. But what if we abused this system? Returning to our earlier example, what happens when we bind two variables to a box?</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>let a = Box::new([0; 1_000_000]);
let b = a;
<span class="boring">}</span></code></pre>
<p>The boxed array has now been bound to both <code>a</code> and <code>b</code>. By our "almost correct" principle, Rust would try to free the box's heap memory <em>twice</em> on behalf of both variables. That's undefined behavior too!</p>
<p>To avoid this situation, we finally arrive at ownership. When <code>a</code> is bound to <code>Box::new([0; 1_000_000])</code>, we say that <code>a</code> <strong>owns</strong> the box. The statement <code>let b = a</code> <strong>moves</strong> ownership of the box from <code>a</code> to <code>b</code>. Given these concepts, Rust's policy for freeing boxes is more accurately described as:</p>
<blockquote>
<p><strong>Box deallocation principle (fully correct):</strong> If a variable owns a box, when Rust deallocates the variable's frame, then Rust deallocates the box's heap memory.</p>
</blockquote>
<p>In the example above, <code>b</code> owns the boxed array. Therefore when the scope ends, Rust deallocates the box only once on behalf of <code>b</code>, not <code>a</code>.</p>
<h3 id="collections-use-boxes"><a class="header" href="#collections-use-boxes">Collections Use Boxes</a></h3>
<p>Boxes are used by Rust data structures<sup class="footnote-reference" id="fr-boxed-data-structures-1"><a href="#footnote-boxed-data-structures">1</a></sup> like <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>, <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>, and <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> to hold a variable number of elements. For example, here's a program that creates, moves, and mutates a string:</p>
<pre><code class="language-aquascope interpreter horizontal">fn main() {
    let first = String::from("Ferris");`[]`
    let full = add_suffix(first);`[]`
    println!("{full}");
}

fn add_suffix(mut name: String) -&gt; String {
    `[]`name.push_str(" Jr.");`[]`
    name
}
</code></pre>
<p>This program is more involved, so make sure you follow each step:</p>
<ol>
<li>At L1, the string "Ferris" has been allocated on the heap. It is owned by <code>first</code>.</li>
<li>At L2, the function <code>add_suffix(first)</code> has been called. This moves ownership of the string from <code>first</code> to <code>name</code>. The string data is not copied, but the pointer to the data is copied.</li>
<li>At L3, the function <code>name.push_str(" Jr.")</code> resizes the string's heap allocation. This does three things. First, it creates a new larger allocation. Second, it writes "Ferris Jr." into the new allocation. Third, it frees the original heap memory. <code>first</code> now points to deallocated memory.</li>
<li>At L4, the frame for <code>add_suffix</code> is gone. This function returned <code>name</code>, transferring ownership of the string to <code>full</code>.</li>
</ol>
<h3 id="variables-cannot-be-used-after-being-moved"><a class="header" href="#variables-cannot-be-used-after-being-moved">Variables Cannot Be Used After Being Moved</a></h3>
<p>The string program helps illustrate a key safety principle for ownership. Imagine that <code>first</code> were used in <code>main</code> after calling <code>add_suffix</code>. We can simulate such a program and see the undefined behavior that results:</p>
<pre><code class="language-aquascope interpreter shouldFail">fn main() {
    let first = String::from("Ferris");
    let full = add_suffix(first);
    println!("{full}, originally {first}");`[]` // first is now used here
}

fn add_suffix(mut name: String) -&gt; String {
    name.push_str(" Jr.");
    name
}
</code></pre>
<p><code>first</code> points to deallocated memory after calling <code>add_suffix</code>. Reading <code>first</code> in <code>println!</code> would therefore be a violation of memory safety (undefined behavior). Remember: it's not a problem that <code>first</code> points to deallocated memory. It's a problem that we tried to <em>use</em> <code>first</code> after it became invalid.</p>
<p>Thankfully, Rust will refuse to compile this program, giving the following error:</p>
<pre><code class="language-text">error[E0382]: borrow of moved value: `first`
 --&gt; test.rs:4:35
  |
2 |     let first = String::from("Ferris");
  |         ----- move occurs because `first` has type `String`, which does not implement the `Copy` trait
3 |     let full = add_suffix(first);
  |                           ----- value moved here
4 |     println!("{full}, originally {first}"); // first is now used here
  |                                   ^^^^^ value borrowed here after move
</code></pre>
<p>Let's walk through the steps of this error. Rust says that <code>first</code> is moved when we called <code>add_suffix(first)</code> on line 3. The error clarifies that <code>first</code> is moved because it has type <code>String</code>, which does not implement <code>Copy</code>. We will discuss <code>Copy</code> soon — in brief, you would not get this error if you used an <code>i32</code> instead of <code>String</code>. Finally, the error says that we use <code>first</code> after being moved (it's "borrowed", which we discuss next section).</p>
<p>So if you move a variable, Rust will stop you from using that variable later. More generally, the compiler will enforce this principle:</p>
<blockquote>
<p><strong>Moved heap data principle:</strong> if a variable <code>x</code> moves ownership of heap data to another variable <code>y</code>, then <code>x</code> cannot be used after the move.</p>
</blockquote>
<p>Now you should start to see the relationship between ownership, moves, and safety. Moving ownership of heap data avoids undefined behavior from reading deallocated memory.</p>
<h3 id="cloning-avoids-moves"><a class="header" href="#cloning-avoids-moves">Cloning Avoids Moves</a></h3>
<p>One way to avoid moving data is to <em>clone</em> it using the <code>.clone()</code> method. For example, we can fix the safety issue in the previous program with a clone:</p>
<pre><code class="language-aquascope interpreter">fn main() {
    let first = String::from("Ferris");
    let first_clone = first.clone();`[]`
    let full = add_suffix(first_clone);`[]`
    println!("{full}, originally {first}");
}

fn add_suffix(mut name: String) -&gt; String {
    name.push_str(" Jr.");
    name
}
</code></pre>
<p>Observe that at L1, <code>first_clone</code> did not "shallow" copy the pointer in <code>first</code>, but instead "deep" copied the string data into a new heap allocation. Therefore at L2, while <code>first_clone</code> has been moved and invalidated by <code>add_suffix</code>, the original <code>first</code> variable is unchanged. It is safe to continue using <code>first</code>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch04-01-ownership-sec2-moves&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;It can be perfectly safe to have a pointer to freed memory in a stack frame. \nThe important thing is to not *use* that pointer again, e.g. by reading it or freeing it.\n&quot;,&quot;id&quot;:&quot;889ca9ac-0f4b-4abf-82c4-be9cd4d4f7ad&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Having a pointer to freed memory in a stack frame&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Using a pointer that points to freed memory&quot;,&quot;Freeing the same memory a second time&quot;,&quot;Using a non-boolean value as an `if` condition&quot;],&quot;prompt&quot;:&quot;Which of the following is NOT a kind of undefined behavior?&quot;}},{&quot;context&quot;:&quot;This program is valid because `s` is not used after moving it into `add_suffix`.\n&quot;,&quot;id&quot;:&quot;94425a4e-043e-47f8-9fba-c5b09fb60aa3&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;hello world&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn add_suffix(mut s: String) -&gt; String {\n  s.push_str(\&quot; world\&quot;);\n  s\n}\n\nfn main() {\n  let s = String::from(\&quot;hello\&quot;);\n  let s2 = add_suffix(s);\n  println!(\&quot;{}\&quot;, s2);\n}\n&quot;}},{&quot;context&quot;:&quot;Because `s` could be moved inside of the if-statement, it is illegal to use it on line 8.\nWhile the if-statement will never execute in this program because `b` is always `false`,\nRust does not in general try to determine whether if-statements will or won't execute. Rust just\nassumes that it *might* be executed, and therefore `s` *might* be moved.\n&quot;,&quot;id&quot;:&quot;c00e3638-861b-4f9e-a55c-bfb67af79280&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:8},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn main() {\n  let s = String::from(\&quot;hello\&quot;);\n  let s2;\n  let b = false;\n  if b {\n    s2 = s;\n  }\n  println!(\&quot;{}\&quot;, s);\n}\n&quot;}},{&quot;context&quot;:&quot;The key idea is that when a box is passed to `move_a_box`, its memory is deallocated after `move_a_box` ends.\nTherefore:\n* Reading `b` via `println` after `move_a_box` is undefined behavior, as it reads freed memory.\n* Giving `b` a second owner is undefined behavior, as it would cause Rust to free the box a second time on behalf of `b2`. It doesn't matter whether the `let b2 = b` binding happens\n  before or after `move_a_box`.\n\nHowever, doing `let b2 = b` and then `println` is not undefined behavior. Although `b` is moved, its data is not deallocated until `move_a_box` is called at the end. Therefore \nthis program is technically safe, although still rejected by Rust.\n&quot;,&quot;id&quot;:&quot;f7d67c11-60bb-4d92-8cc2-8ce82cf4c974&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;```\nlet b = Box::new(0);\nlet b2 = b;\nmove_a_box(b);\n```\n&quot;,&quot;```\nlet b = Box::new(0);\nmove_a_box(b);\nprintln!(\&quot;{}\&quot;, b);\n```\n&quot;,&quot;```\nlet b = Box::new(0);\nmove_a_box(b);\nlet b2 = b;\n```\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\nlet b = Box::new(0);\nlet b2 = b;\nprintln!(\&quot;{}\&quot;, b);\nmove_a_box(b2);\n```\n&quot;,&quot;None of these snippets&quot;],&quot;prompt&quot;:&quot;Say we have a function that moves a box, like this:\n```\nfn move_a_box(b: Box&lt;i32&gt;) {\n  // This space intentionally left blank\n}\n```\n\nBelow are four snippets which are rejected by the Rust compiler. \nImagine that Rust instead allowed these snippets to compile and run. \nSelect each snippet that would cause undefined behavior, or select \n\&quot;None of these snippets\&quot; if none of these snippets would cause undefined behavior.\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-cache-answers="true"></div>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>Ownership is primarily a discipline of heap management:<sup class="footnote-reference" id="fr-pointer-management-1"><a href="#footnote-pointer-management">2</a></sup></p>
<ul>
<li>All heap data must be owned by exactly one variable.</li>
<li>Rust deallocates heap data once its owner goes out of scope.</li>
<li>Ownership can be transferred by moves, which happen on assignments and function calls.</li>
<li>Heap data can only be accessed through its current owner, not a previous owner.</li>
</ul>
<p>We have emphasized not just <em>how</em> Rust's safeguards work, but <em>why</em> they avoid undefined behavior. When you get an error message from the Rust compiler, it's easy to get frustrated if you don't understand why Rust is complaining. These conceptual foundations should help you with interpreting Rust's error messages.  They should also help you design more Rustic APIs.</p>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css"><hr>
<ol class="footnote-definition"><li id="footnote-boxed-data-structures">
<p>These data structures don't use the literal <code>Box</code> type. For example, <code>String</code> is implemented with <code>Vec</code>, and <code>Vec</code> is implemented with <a href="https://doc.rust-lang.org/nomicon/vec/vec-raw.html"><code>RawVec</code></a> rather than <code>Box</code>. But types like <code>RawVec</code> are still box-like: they own memory in the heap. <a href="#fr-boxed-data-structures-1">↩</a></p>
</li>
<li id="footnote-pointer-management">
<p>In another sense, ownership is a discipline of <em>pointer</em> management. But we haven't described yet about how to create pointers to anywhere other than the heap. We'll get there in the next section. <a href="#fr-pointer-management-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="js-extensions/packages/telemetry/dist/index.js"></script>
        <script src="js-extensions/packages/feedback/dist/index.js"></script>



    </div>
    </body>
</html>
